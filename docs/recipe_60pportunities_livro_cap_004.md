<p align="justify">AO início do século XXI viu a emergência de novas metodologias ágeis, como Scrum, Kanban, Lean, e Extreme Programming, que revolucionaram a forma como os projetos de software eram geridos. Essas metodologias colocam ênfase na colaboração contínua, na adaptação às mudanças e na entrega rápida de funcionalidades, em contraste com as abordagens mais rígidas e sequenciais que prevaleciam anteriormente. Além disso, a crescente ubiquidade dos dispositivos móveis e a ascensão da computação em nuvem abriram novas fronteiras para o desenvolvimento de software, permitindo a criação de aplicações mais dinâmicas, escaláveis e acessíveis.</p>

<p align="justify">Ao longo das décadas, a história dos projetos de software tem sido uma história de adaptação e inovação constante. Cada avanço tecnológico trouxe consigo novos desafios e oportunidades, impulsionando a evolução contínua das práticas e ferramentas utilizadas no desenvolvimento de software. Hoje, os projetos de software são parte integrante de quase todos os aspectos da vida moderna, desde a comunicação e o comércio até a educação e o entretenimento, refletindo a importância crescente do software em nosso mundo interconectado.</p>

## KANBAN - 2000s
Origem: O método Kanban foi adaptado do gerenciamento de produção industrial (Toyota), e começou a ser utilizado em desenvolvimento de software na década de 2000.
Características: Foco na visualização do fluxo de trabalho, limitando o número de tarefas em progresso e otimizando a entrega contínua.
Limitações: Pode ser difícil de adotar sem uma cultura de melhoria contínua e foco em fluxo de trabalho eficiente.
![](img/linha-do-tempo.png){width="600" height="20" style="display: block; margin: 0 auto"}

- [x] 2000: Google Sheets (início como parte de Writely) – A versão inicial das planilhas baseadas na web começou a surgir, mais tarde evoluindo para Google Sheets como parte do Google Docs em 2006.
- [x] 2000: Basecamp – Um dos primeiros softwares de gerenciamento de projetos baseado na web.
- [x] 2000: A SoftBank do Japão apresenta o primeiro telefone com câmera, o J-Phone J-SH04; um telefone digital fabricado pela Sharp com câmera integrada.
- [x] O PlayStation 2 (PS2) representa uma mudança significativa no conceito de consoles de jogos. 
- [x] Pen Drive - Os drives USB Flash são introduzidos
- [x] Bug do Milênio: O problema estava enraizado no fato de que os carimbos de data na maioria dos softwares escritos anteriormente usavam apenas dois dígitos para representar as informações do ano.

## Agile (Manifesto Ágil) - 2001
<p align="justify">O Manifesto Ágil surgiu da necessidade de uma abordagem mais eficiente e centrada no valor do que as metodologias tradicionais de desenvolvimento de software.</p>
<p align="justify">Representantes de várias disciplinas de desenvolvimento de software se reuniram em 2001 para criar uma alternativa à documentação intensiva e processos focados.</p>
<p align="justify">O objetivo era desenvolver software que entregasse valor, atendesse às expectativas dos clientes e proporcionasse um ambiente de trabalho motivador.</p>
### Os Quatro Valores do Manifesto Ágil
- [x] Indivíduos e interações acima de processos e ferramentas: O foco deve ser nas pessoas e em sua capacidade de colaborar, em vez de seguir processos rígidos ou depender de ferramentas.
- [x] Software funcional acima de documentação abrangente: O progresso é medido pela entrega de software que funciona e agrega valor ao cliente, não pela produção de documentos extensos.
- [x] Colaboração com o cliente acima de negociação de contratos: O relacionamento com o cliente deve ser baseado na confiança e colaboração, em vez de contratos formais e rígidos.
- [x] Resposta à mudança acima de seguir um plano: O desenvolvimento de software deve ser flexível e capaz de se adaptar a mudanças nos requisitos, em vez de seguir um plano fixo.

### Princípios de Suporte ao Manifesto Ágil
- [x] Satisfação do cliente: Priorizar a entrega contínua de software valioso para satisfazer o cliente.
- [x] Bem-vindos à mudança: Acolher mudanças nos requisitos, mesmo tardiamente, para garantir uma vantagem competitiva para o cliente.
- [x] Entregar software funcional com frequência: Entregar software funcional em intervalos curtos, com preferência por prazos mais curtos.
- [x] Colaboração diária: Desenvolvedores e pessoas de negócios devem trabalhar juntos diariamente.
- [x] Indivíduos motivados: Construir projetos em torno de indivíduos motivados, fornecendo o ambiente e suporte necessários.
- [x] Conversa face a face: A comunicação face a face é o método mais eficiente para troca de informações.
- [x] Software funcional como medida de progresso: O software funcional é a principal medida de progresso, não outras métricas como tempo gasto ou orçamento.
- [x] Ritmo constante: Promover um desenvolvimento sustentável, mantendo um ritmo constante indefinidamente.
- [x] Excelência técnica: Buscar constantemente a excelência técnica e bom design, pois isso aumenta a agilidade.
- [x] Simplicidade: Maximizar a quantidade de trabalho não feito. Implementar apenas o mínimo necessário.
- [x] Equipes auto-organizadas: As melhores arquiteturas, requisitos e designs emergem de equipes auto-organizadas.
- [x] Refletir e ajustar: A equipe deve refletir sobre como se tornar mais eficaz e ajustar seu comportamento.
### Valores Ágeis
Os valores ágeis como verdade, transparência, confiança, respeito e compromisso devem ser aplicados tanto no desenvolvimento de software quanto na vida cotidiana.
### Importância da Entrega Contínua e Ritmo Constante
A entrega contínua de software com valor é essencial para a satisfação do cliente e para responder às mudanças.
É preciso um ritmo constante de trabalho, o que significa manter a equipe trabalhando de forma consistente.
Variabilidade no ritmo leva a incerteza e dificuldade em planejar.
### Fatores que Impedem a Adoção do Agile:
- [x] Resistência à mudança por parte de pessoas e departamentos.
- [x] Falta de infraestrutura para entrega contínua.
- [x] Falta de clareza sobre o valor para o cliente.
- [x] Liderança inadequada, que não prioriza a motivação da equipe.
- [x] Falta de confiança e comunicação aberta.
- [x] Acumulação de dívida técnica e má qualidade de código.

![](img/linha-do-tempo.png){width="600" height="20" style="display: block; margin: 0 auto"}

- [x] 2001: BitTorrent, um serviço de compartilhamento de arquivos peer-to-peer, é lançado pela BitTorrent, Inc. 
- [x] O Mac OS X é lançado.
- [x] Idealizado pelo lendário diretor Stanley Kubrick, mas dirigido por Steven Spielberg após a morte de Kubrick, AI conta a história de David, um robô humanoide que pode sentir e expressar emoções.
- [x] O sistema operacional Windows XP é lançado.
- [x] O iTunes da Apple é lançado. 
- [x] 2001: Selenium – Lançado inicialmente como Selenium Core, tornou-se uma das ferramentas de automação de testes mais populares.

## Modelo Test Driven Development (TDD)
<p align="justify">O TDD foi formalizado por Kent Beck, um dos pioneiros das metodologias ágeis, como parte de sua abordagem de desenvolvimento de software dentro do contexto do Extreme Programming (XP). Beck escreveu o livro "Test-Driven Development: By Example", publicado em 2002, que descreve a prática de escrever testes antes de escrever o código funcional, com o objetivo de garantir que o código esteja sempre testado e refatorável.</p>

<p align="justify">A prática de TDD já estava em desenvolvimento por alguns anos, mas foi com a obra de Kent Beck que ela foi sistematizada e disseminada.</p>

- [x] 2002: Implantado o e-Business Suite na BBTS, após um ano de suspensão das atividades de levantamento.
- [x] 2002: Implantação do e-Business Suite na Cobra Computadores;
- [x] 2002: OpenOffice Calc – Parte da suíte de escritório OpenOffice, um software de código aberto para planilhas.
- [x] 2002: Primavera P6 – Atualização para projetos mais robustos e integração empresarial.
- [x] 2002: TestNG – Framework de testes inspirado no JUnit, com suporte avançado para funcionalidades como paralelismo.

## LEAN Software Development - 2003
Baseado nos princípios do Lean Manufacturing (Toyota), o Lean Software Development foi introduzido por Mary e Tom Poppendieck.
- [x] Características: Foco em eliminar desperdícios, melhorar a eficiência e fornecer valor contínuo ao cliente.
- [x] Limitações: Exige um comprometimento com a eliminação de desperdícios, o que pode ser difícil para empresas que já têm processos estabelecidos.
![](img/linha-do-tempo.png){width="600" height="20" style="display: block; margin: 0 auto"}

- [x] 2003: Blue Prism – Fundado no Reino Unido, é considerado o pioneiro em RPA empresarial, introduzindo o conceito de “trabalhadores digitais”.
- [x] 2004: Em 2004, o Google é a primeira grande empresa da Web a lançar uma ação negociada publicamente desde os dias de euforia do boom das pontocom. 
- [x] 2004: HP Quality Center (anteriormente TestDirector) – Uma plataforma robusta para gestão de testes e qualidade.

## ATDD (Acceptance Test-Driven Development)
- [x] Criadores: Alistair Cockburn, com contribuições de outros, como Ron Jeffries
- [x] Ano de publicação: 2005 (mais ou menos)
- [x] Contexto: O ATDD compartilha algumas semelhanças com o BDD, mas seu foco está na criação de testes de aceitação antes de iniciar o desenvolvimento, com ênfase no entendimento das expectativas do cliente. O conceito foi introduzido por Alistair Cockburn em 2005, em conjunto com outras práticas ágeis. ATDD envolve a colaboração entre clientes, desenvolvedores e testadores para definir claramente os critérios de aceitação de uma funcionalidade e garantir que esses critérios sejam atendidos.

No ATDD, os testes de aceitação geralmente são mais detalhados e orientados para o comportamento funcional do sistema em um nível mais alto, enquanto o BDD foca na especificação do comportamento do software a partir de exemplos.
![](img/linha-do-tempo.png){width="600" height="20" style="display: block; margin: 0 auto"}

- [x] 2005: Kit inicial Arduino
- [x] Hadoop é um projeto de software de código aberto desenvolvido inicialmente pelo Google como um meio de extrair resultados de pesquisa de grandes quantidades de dados não estruturados, como dados encontrados na web. 
- [x] O veículo autônomo da Stanford Racing Team, "Stanley", vence o "Grand Challenge" da DARPA de 2005, realizado perto de Las Vegas. 
- [ ] 2005: UiPath (início como DeskOver) – Criado como uma empresa de automação de software em Bucareste, começou como uma ferramenta de automação simples para Windows.
- [x] 2006: O Amazon Web Services é lançado.
- [x] Sistema de jogo Wii da Nintendo não introduz apenas novos jogos e controles, mas novas maneiras de interagir com os sistemas de jogo. 
- [x] Fundado por um grupo de jornalistas e registrado na Islândia, o WikiLeaks serve como uma câmara de compensação para informações secretas, vazamentos de notícias e material anônimo. 
- [x] 2006: Automation Anywhere – Inicialmente conhecida como Tethys Solutions, lançou uma plataforma de automação com foco em integração empresarial.
- [x] 2006: Google Docs – Lançado como parte do Google Suite, trouxe edições colaborativas na nuvem.

- [x] 2007: A Hitachi Global Storage Technologies anuncia o primeiro disco rígido (HDD) de 1 TB. 
- [x] O Amazon Kindle é lançado;
- [x] A Apple lança o iPhone - uma combinação de navegador da web, tocador de música e telefone celular - que podia baixar novas funcionalidades na forma de "apps" (aplicativos) da loja online da Apple. 

Principais Temas e Conceitos

Desenvolvimento de Software e a Importância dos Testes de Aceitação:
O livro contrasta duas abordagens de desenvolvimento de software, destacando que testes de aceitação feitos antes da implementação são mais valiosos que testes feitos depois.
Testes de aceitação, que devem ser compreendidos pelo cliente, determinam se um software é aceitável. "O resultado de quase todo teste de aceitação pode ser expresso em termos de sim ou não."
Além dos testes de aceitação, há os testes de propriedades (não funcionais) como escalabilidade e segurança.
Princípios Lean e Agile:
A metodologia Lean e Agile enfatiza feedback rápido e testes de aceitação desde o início do processo de desenvolvimento. "Feedback rápido é melhor do que feedback lento."
A colaboração entre o cliente, desenvolvedor e testador é essencial para definir os testes de aceitação.
Estratégia de Teste:
O livro aborda diferentes tipos de testes, onde eles são executados e como eles devem ser controlados e observados.
A criação de um novo teste significa, na prática, o surgimento de um novo requisito. "Novo teste é um novo requisito."
Testes devem ser executados em várias camadas (interface de usuário, camada intermediária, testes de unidade).
Testes de Aceitação Introdutórios:
O livro demonstra a implementação de testes de aceitação utilizando exemplos práticos, incluindo scripts, interfaces, testes xUnit e testes automatizados.
Os testes devem refletir as regras de negócio, com exemplos claros e compreensíveis.
Projetos de Exemplo:
É apresentada uma estrutura de projeto que envolve definição de objetivos SMART (Específico, Mensurável, Atingível, Relevante e com Tempo definido), requisitos de alto nível, features, critérios de aceitação de features.
O uso de histórias de usuário e personas são explicadas para melhor definir o desenvolvimento. "Antes de começarmos as histórias de usuário, precisamos identificar alguns papéis que estarão envolvidos nas histórias. Estes papéis não são necessariamente pessoas específicas, mas os 'chapéus' que as pessoas vestem no processo de locação e são importantes de revelar."
Técnica de Histórias de Usuário:
Histórias de usuários são usadas para quebrar features em partes menores e gerenciáveis.
Os critérios de aceitação das histórias são vitais para a definição do tamanho das histórias. "Testes de aceitação determinam o tamanho."
As histórias devem seguir os critérios INVEST (Independentes, Negociáveis, Valiosas, Estimáveis, Pequenas, Testáveis).
Colaboração em Cenários:
O livro explora o uso de casos de uso (use cases) a partir de histórias de usuário, incluindo cenários simples, exceções e alternativas.
Cenários devem ser documentados para gerar testes de aceitação mais abrangentes.
A comunicação e o fluxo conceptual são essenciais para o desenvolvimento.
Anatomia do Teste:
Testes são criados pela colaboração do triad (cliente, desenvolvedor e testador).
É importante definir o contexto e a estrutura do teste, utilizando tabelas de cálculo, tabelas de dados e tabelas de ação. "A estrutura é usada principalmente para cálculos."
Testes devem ser executados em diferentes níveis e momentos do desenvolvimento.
Testes de Cenário:
É discutida a criação de testes para cenários de exceção e regras de negócios.
Os testes podem ser de vários níveis, incluindo interface de usuário.
Nem tudo precisa ser automatizado, com foco nos objetivos principais do projeto.
Quebra de Histórias de Usuário:
Testes de aceitação ajudam a quebrar histórias de usuário em partes menores.
Testes das regras de negócio. "Esta é um teste simples de regra de negócio. Você pode testá-lo conectando-se ao módulo que implementa a regra. Então você precisa criar um teste que assegure que a regra de negócio está corretamente conectada ao processo de check-out."
Limites do Sistema:
A definição das interfaces externas e testes de interfaces são cruciais.
Testes de componente (test doubles) e mocks são usados para simular o comportamento das interfaces externas. "Na verdade, sempre que há alguma interface externa para um sistema, eu normalmente crio um test double."
O mapa de histórias de atividades pode ajudar a visualizar a dinâmica do sistema.
Revisão do Desenvolvimento:
O livro aborda o ciclo completo do desenvolvimento de software.
A importância de testes de usabilidade, separação de estado e display e testes de atributos de qualidade.
Planos de implementação e a evolução do projeto, desde o "charter" até a entrega.
Simplificação por Separação:
Regras de negócios complexas podem ser simplificadas através da separação em partes menores.
"Com todas essas comparações e condições complexas, esta é uma tabela difícil de entender. Podemos quebrá-la em tabelas menores, se o Sam nos deixar ou você nos deixar, em vez do Sam estar aqui."
É apresentado o exemplo da história de locação para melhor exemplificar esta separação.
Separar View do Model:
É importante desacoplar a interface de usuário do modelo, simplificando os testes. "A separação da interface de usuário do serviço."
O desacoplamento simplifica os testes e garante que a lógica do negócio seja consistente.
Eventos, Respostas e Estados:
A importância de eventos, tabelas de eventos, estados, transições de estado, estados internos e externos, estados transientes e persistentes.
"Para o sistema do Sam, os dados serão tratados como internamente persistentes. Alugar um CD pela segunda vez causa uma saída diferente porque o estado do sistema é diferente. Parte de um teste envolve especificar qual é o estado atual do sistema."
Testes de Aceitação de Desenvolvedores:
Testes de aceitação de componentes, testes de display de campos e testes de display tabular.
Desacoplar com Interfaces:
Testes para um provedor de serviço.
A importância da interface e de testes dos atributos de qualidade.
Comparar implementações e separar a interface de usuário do serviço para promover a reutilização das regras de negócios.
Entidades e Relacionamentos:
Exploração dos relacionamentos entre entidades.
Representações alternativas para melhorar o entendimento do modelo de dados. "Tanto a estrutura, quanto a representação, podem influenciar o entendimento do problema."
Triads para Sistemas Grandes:
Como aplicar o conceito de triads em sistemas maiores.
Situações onde um teste de cliente pode não ser obrigatório.
A importância da conversão de dados e de base de dados.
O que fazer quando não há testes e como lidar com sistemas legados.
Capacidades de Negócios, Regras e Valor:
Discute a importância das capacidades de negócios e a entrega de valor. "O preço é o que você paga. O valor é o que você recebe."
Expondo as regras de negócio, que são independentes da tecnologia. "Uma regra de negócio é algo que é verdade, independentemente da tecnologia que é empregada."
Diferentes visões de valor de negócio e as suas implicações no projeto.
Apresentação de Testes:
Testes devem ser legíveis pelos clientes utilizando tabelas, que podem ser horizontais ou verticais. "Algumas pessoas são orientadas horizontalmente. Outras são orientadas verticalmente."
Especificar múltiplas ações para um teste e como apresentar dados complexos através de tabelas.
Avaliação de Testes:
Testes devem ser compreensíveis, com verificação ortográfica, idempotentes, não frágeis e em sequência. "Certifique-se de que os testes são compreensíveis aos clientes."
As condições do teste e a separação de questões são importantes.
Lidar com a falha do teste e a redundância. "Evite a redundância do teste."
Não incluir detalhes de implementação no teste.
Usando Testes para Outras Coisas:
Testes de aceitação medem o quão completo um software está, estimam o esforço para implementar uma história de usuário, auxiliam na quebra de histórias e servem como report de bugs. "Os testes de aceitação definem a funcionalidade de um programa."
Usando testes para análise de causa raiz, bugs de produção e teste de regressão.
Contexto e Linguagem de Domínio:
A importância de uma linguagem Ubíqua para o domínio do problema. "A aplicabilidade de uma linguagem ubíqua pode ser toda a empresa."
Definição de termos usando tabelas e exemplos.
Retrospectiva e Perspectiva:
Recapitulando o processo de teste.
Abordando os blocos que podem surgir como, por exemplo, a indisponibilidade do cliente. "Não trabalhe nesse projeto até que o cliente forneça testes de aceitação específicos."
Analisando os riscos e benefícios de testes de aceitação.
Estudo de Caso: Contribuições para a Aposentadoria:
Contexto e testes principais.
Configuração, evento e resultado esperado.
Abordagem de questões de implementação e separação de responsabilidades.
Rastreamento do valor de negócio e como tratar as exceções e as exceções simultâneas.
Apresentação do quadro geral com tabelas de eventos e transição de estados.
Estudo de Caso: Processamento de Sinal:
Contexto dos níveis de som e testes do desenvolvedor. "Este projeto é sobre níveis de som."
Estudo de Caso: Um Servidor de Impressão da Biblioteca:
Contexto do caso e um exemplo de teste de fluxo de trabalho. "O contexto é sobre um servidor de impressão."
Estudo de Caso: Plataforma de Alta Disponibilidade:
Contexto para trocar servidores.
Testes para trocar de servidor e para regras técnicas.
Como se Encaixa com ATDD:
Plataformas de testes, desenho interno usando testes e testes de dispositivos. "O desenho interno a partir de testes."
Começando com interfaces de usuário, black box e testes unitários.
Configuração de Testes:
Configuração comum e suas melhorias.
Ordem dos testes e questões de armazenamento persistente.
Estudo de Caso: Endereços de E-Mail:
Contexto do teste de endereços de e-mail e quebra de testes.
Validação da parte local do e-mail e os testes do domínio. "Quebre as condições complicadas em condições menores. Condições menores são mais fáceis de testar e codificar."
Garantia de conexão e testes de verificação.
Apêndices:
Outras questões como testes de aceitação fuzzy e detalhe de testes.
Requisitos e testes de aceitação, com documentação e desacoplamento.
Separação de problemas, testes de sistemas com eventos aleatórios e o poder do três.
Estimando o valor de negócio e exemplos de frameworks de testes. "Comece com o quadro geral."
Tabelas em todos os lugares, dinheiro com ATDD, e exemplos de exercícios.
Conclusão

O livro enfatiza a importância de utilizar os testes de aceitação em um ambiente Lean-Agile para melhorar a colaboração e garantir que o software entregue o valor desejado pelo cliente. O foco principal é colocar o teste no centro do processo de desenvolvimento, garantindo que o código seja construído para satisfazer os requisitos, de forma eficiente e eficaz. A abordagem de ATDD promove feedback rápido, melhor comunicação entre as equipes e a entrega de software de alta qualidade, alinhado com as necessidades do negócio.

Espero que este resumo detalhado ajude a entender os conceitos do livro. Se tiver mais perguntas, por favor, me diga!


## BDD (Behavior-Driven Development)
- [x] Criadores: Dan North (inicialmente), mais tarde com contribuições de outros como Aslak Hellesøy

- [x] Ano de publicação: 2003 (inicialmente), com maior difusão a partir de 2008

- [x] Contexto: O BDD surgiu como uma evolução do TDD, com foco em comportamentos e na comunicação mais eficaz entre desenvolvedores, testadores e clientes. Dan North foi o principal responsável por popularizar o BDD ao perceber que a terminologia e a abordagem do TDD, muitas vezes, dificultavam a colaboração entre as partes interessadas no software. Em 2003, ele introduziu o conceito de "Spec by Example" e, em 2008, isso foi formalizado como BDD, com a criação de ferramentas como o Cucumber (em colaboração com Aslak Hellesøy) que ajudavam a descrever os comportamentos do sistema em linguagem natural (Gherkin).
- [x] O BDD enfatiza a colaboração entre as equipes para entender os requisitos e comportamentos do sistema e transformá-los em testes automatizados que verificam esses comportamentos.
- [x] Em vez de escrever testes focados na implementação, o BDD prioriza a especificação do comportamento esperado do software, usando exemplos concretos que são compreensíveis para todos, incluindo stakeholders não técnicos.
- [x] Especificações Executáveis: O BDD transforma exemplos concretos em especificações executáveis, que servem tanto como documentação viva quanto como testes automatizados. Essas especificações são geralmente escritas em uma linguagem compreensível por todos, como Gherkin, usando a estrutura "Dado ... Quando ... Então".
- [x] Feature Injection e Definição de Requisitos: "Feature Injection", que envolve a identificação do valor de negócio, a definição de metas claras, a identificação de stakeholders e a derivação de funcionalidades (features) a partir dessas metas. O processo começa com uma visão clara do produto e a compreensão de como o software beneficiará o negócio.
- [x] Citação: "O primeiro passo na injeção de recursos é "caçar o valor". Mas é muito mais fácil identificar o valor que você espera de um projeto se você tiver uma ideia clara da visão geral do projeto."
- [x] Exemplos e Cenários: Os exemplos desempenham um papel central no BDD. Os exemplos concretos ilustram o comportamento desejado, auxiliando na compreensão e na comunicação. Os exemplos são então formalizados em cenários, usando a estrutura "Dado ... Quando ... Então".
- [x] Citação: "Quando você automatiza seus critérios de aceitação usando esse tipo de ferramenta BDD, você expressa seus exemplos em um formato um pouco mais estruturado, geralmente chamado de cenários."
- [x] Da Especificação ao Código: O BDD não se limita à fase de especificação. Ele também influencia o design e a implementação do software. A estrutura "Dado ... Quando ... Então" é usada tanto em especificações de alto nível quanto em testes unitários de baixo nível, guiando o desenvolvimento do software.
- [x] Automatização e Ferramentas: Diversas ferramentas de automação para BDD, como JBehave, Cucumber-JVM, SpecFlow e Behave, demonstrando como cenários podem ser transformados em testes automatizados. Também destaca ferramentas auxiliares como Thucydides.
- [x] Testes Unitários e BDD: Explora como aplicar os princípios do BDD no nível dos testes unitários, utilizando ferramentas como Spock e RSpec para criar especificações executáveis de baixo nível. O livro reforça a ideia de que os testes podem servir como documentação viva do código, ao usar nomes claros e expressivos e ao focar o comportamento dos objetos sob teste.
- [x] Integração Contínua e Entrega Contínua: O BDD se integra com as práticas de Integração Contínua e Entrega Contínua, garantindo que as especificações executáveis sejam validadas regularmente durante o processo de desenvolvimento.
- [x] A Visão (Vision Statement): É fundamental começar com uma visão clara do produto. Essa visão deve ser expressa através de uma declaração concisa que responde ao "Porquê" do projeto.
- [x] Objetivos de Negócio (Business Goals): Os objetivos de negócio devem ser SMART (Specific, Measurable, Achievable, Relevant, Time-bound) para orientar o desenvolvimento e medir o sucesso. O "Porquê" do projeto é primordial e deve ser explícito.
- [x] Mapeamento de Impacto (Impact Mapping): É uma técnica visual para explorar as ramificações das metas de negócio, identificando os atores, os impactos desejados e as funcionalidades necessárias.
- [x] Capacidades (Capabilities): As capacidades descrevem o que o sistema deve ser capaz de fazer para alcançar as metas de negócio.
- [x] Funcionalidades (Features): As funcionalidades entregam capacidades e podem ser divididas em partes menores e mais gerenciáveis. São descritas com user stories ou através de "In order to ... As a ... I want to..."
- [x] User Stories: São artefatos de planejamento que podem ser descartados no final de cada iteração, mas que ajudam a refinar o entendimento de cada funcionalidade. Uma funcionalidade pode ser decomposta em várias user stories.
- [x] Exemplos Concretos: São a base da especificação, usados para ilustrar o comportamento desejado de cada funcionalidade.
- [x] Cenários: São exemplos formalizados usando a estrutura "Dado ... Quando ... Então". Em ferramentas como Gherkin, os cenários são estruturados em arquivos de feature.
- [x] Arquivos de Feature: Agrupam todos os cenários relacionados a uma funcionalidade.
- [x] Tabelas de Exemplos: Permitem expressar múltiplos cenários relacionados em uma única representação.
- [x] Tags: Permitem categorizar cenários.
- [x] Stubs e Mocks: São usados no nível de testes unitários para isolar dependências e facilitar o teste de funcionalidades específicas.
- [x] Linguagem Ubíqua: A linguagem utilizada nos cenários deve ser a mesma usada por todos os envolvidos no projeto, incluindo os stakeholders.
- [x] Ferramentas: JBehave (Java), Cucumber-JVM (Java), SpecFlow (.NET), Behave (Python), Spock (Groovy), RSpec (Ruby), JUnit/NUnit/TestNG (Java/.NET).
- [x] Ciclo de Vida: O BDD não é restrito a uma fase do ciclo de vida do software. Ele influencia todo o processo, da definição de requisitos ao deployment.

O BDD também envolve uma forma de colaboração, focada na comunicação e no entendimento compartilhado do valor do software para o negócio. Ao seguir esses princípios, as equipes de desenvolvimento podem construir software de maior qualidade, que atenda melhor às necessidades dos usuários e stakeholders.

![](img/livro-007.png)

- [x] 2008: A Apple apresenta seu primeiro ultra notebook – um laptop leve e fino com bateria de alta capacidade. 
