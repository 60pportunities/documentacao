 Desafie-se com os desafios do GitHub
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Com mais de 65 milhões de desenvolvedores e 200 milhões de repositórios, o GitHub é o lugar que os desenvolvedores usam para construir, enviar e manter código. Ei, aí. Este é Ray Villalobs. E neste curso, vou desafiá-lo a usar o GitHub para resolver diferentes problemas em seus projetos. E começaremos com alguns comandos básicos do Git. Em seguida, faça um pouco de viagem no tempo alterando históricos e, em seguida, passe para a automação usando os scripts de terminal e bash. Acabaremos com diferentes maneiras de usar as Ações do GitHub, executar relatórios de acessibilidade, usar segredos e criar e implantar seu site. Agora, a maioria das soluções tem menos de uma dúzia de linhas de código e a maioria dos vídeos pode ser assistida por conta própria e não exige que você tenha concluído os desafios anteriores. Então, boa sorte e vamos começar a barulhar. (carrilhões da máquina)

 Clonar um repositório com um histórico vazio
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(sons eletrônicos) - [Instrutor] Vamos começar com algo que pode ser um pouco útil para este curso. Como você faz uma cópia de um repositório existente sem copiar nada de seu histórico, mesmo que o repositório não seja seu? Vou dar-lhe alguns segundos para pausar o vídeo e ver como você teria resolvido isso. (sons eletrônicos) Tudo bem, há algumas maneiras de fazer isso. A parte difícil é que eu quero uma história limpa. Isso não está associado ao repositório original. Agora você poderia forjar o repo, mas você só pode fazer isso uma vez. E então você ainda teria um link para o original. Outra maneira é criar um repositório de modelos, mas você só pode fazer isso se for o proprietário do repositório. Mas há uma maneira muito mais rápida e flexível. Você pode usar um projeto chamado Degit por Rich Harris, o criador deste framework Vout. O Degit permite que você faça exatamente o que estamos procurando. Também precisaremos usar o npx, que vem quando você instala o NodeJS, o comando se parece com isso. Agora o npx permitirá que você use temporariamente um projeto sem ter que baixá-lo para que possamos executar o projeto Degit. A partir daí, você pode especificar um nome de usuário do GitHub, embora o padrão seja GitHub. Ele também funcionará com outros produtos como Bitbucket e GitLab, adicionando-o como um prefixo com ponto-e-vírgula. Além do nome de usuário, você pode especificar o nome de um projeto. Você pode até optar por copiar apenas uma versão de ramificação ou hash existente, adicionando-o após um símbolo de hashtag e, finalmente, especifique o que deseja chamar o projeto localmente, separando o nome com um espaço. Vamos tentar este comando. Vou mudar para o hiper, que é o meu terminal. Vou me certificar de que mudei para a área de trabalho e, em seguida, também emiti o comando npx Degit. E eu vou segmentar o grupo de aprendizado do LinkedIn e, em seguida, digitar o nome do repositório que eu quero a cópia. E então eu vou digitar o nome que eu quero chamar isso localmente. Vou bater enter. E eu vou dizer sim aqui. Agora isso vai clonar o repositório para a minha área de trabalho. Como este é um novo repo, você ainda precisará inicializar o git, criar um repositório e, em seguida, enviá-lo para o GitHub. Mas é a maneira mais rápida de começar com uma história limpa. Vou usar algo assim para copiar projetos limpos do GitHub. Quando eu mostro alguns dos outros desafios.

 Como você mescla um histórico linear?
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(sons de videogame) - [Instrutor] Digamos que você esteja trabalhando em um novo recurso para o seu projeto, mas, enquanto isso, alguém está trabalhando em um recurso diferente e já o enviou para o GitHub e mesclou esse commit em sua ramificação principal. Qual é uma boa maneira de adicionar seus commits após os commits sem criar uma linha do tempo confusa? Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode ter resolvido isso. (Música de videogame de 8 bits) Um dos primeiros comandos que você aprende ao trabalhar com o GitHub é como mesclar suas alterações em uma ramificação mestre. A mesclagem é o mais comum dos comandos de mesclagem, mas há outra estratégia de mesclagem que funcionará melhor para criar um histórico mais linear que leve em conta outras alterações que os usuários possam ter realizado. Aqui está uma cópia do projeto na minha máquina local. No momento, estou em uma filial chamada CleanUp. Para ver o histórico de confirmação, posso emitir um comando no meu terminal. Vou fazer um git log com a opção oneline. Isso me mostra que houve dois compromissos; a primeira confirmação e outra em que fiz algumas pequenas alterações no arquivo README. Eu já adicionei este projeto ao GitHub, então vamos lá. Se dermos uma olhada na seção de filiais, você verá que há apenas uma filial. Se quisermos ver as confirmações, podemos simplesmente alterar essa tag de ramificações aqui para confirmar. Você verá que há uma confirmação adicional aqui na parte superior. Nesse caso, fiz essa alteração, mas pode ser que outra pessoa tenha adicionado algo ao projeto enquanto você estava trabalhando em sua ramificação de limpeza. Voltemos ao meu editor. Quero excluir a pasta do GitHub, que tem alguns modelos que não precisarei mais. Vamos em frente e clique com o botão direito do mouse sobre isso e diga excluir. Isso vai se livrar dessa pasta. Precisamos adicionar e comprometer essa mudança ao meu projeto. Vou em frente e empurrar isso para o GitHub. Talvez eu precise definir a origem a montante, uma vez que este é um novo projeto. Vamos em frente e limpar nossa tela e voltar para o GitHub. Se eu voltar ao meu projeto, você verá que isso gerou uma oferta para comparar e puxar essa nova ramificação. Vamos em frente e clique nisso. Você pode ver aqui embaixo que as mudanças são bem simples. Vamos em frente e criar esta solicitação pull. Quando você mescla um projeto, na maioria das vezes, pressionamos esse botão de solicitação pull de mesclagem, mas na verdade temos três opções diferentes para fazer solicitações de mesclagem. A terceira opção, a re-base, nos dará uma história mais limpa. Ele adicionará todos os meus compromissos após os compromissos que já foram feitos. Vamos dizer re-base e mesclar. Vou clicar em confirmar, e essa solicitação pull agora foi mesclada e fechada com êxito. Eu posso excluir esta ramificação se eu quiser. Posso escrever um comentário e adicioná-lo a este compromisso. Vamos dar uma olhada nos commits mais uma vez. Você pode ver que a confirmação aparece aqui e é depois da confirmação que você ou outra pessoa pode ter feito. É apenas adicioná-lo ao fim da história. Veja como a re-base é diferente. A re-base reproduz uma confirmação no final de uma ramificação. Isso significa que ele cria uma história de projeto mais limpa e linear. Algumas equipes realmente exigem re-basing em vez da metodologia de mesclagem tradicional. Há algumas notas importantes que você deve observar. Embora crie um histórico mais limpo, a re-base está adicionando novos commits ao final da ramificação. Estes são semelhantes, mas tecnicamente diferentes que os compromissos que você fez no passado. A segunda coisa a ser observada é que, por causa disso, é importante que você não re-baseie um ramo público. Crie uma ramificação e, em seguida, use-a para mesclar, pois para criar o histórico mais limpo, ele está ignorando sua ramificação original e fazendo novas cópias de suas confirmações no final da ramificação na qual você está se baseando novamente. Aprender a rebasear em vez de mesclar é um dos primeiros sinais de que você está se transformando em um usuário mais avançado do GitHub.



Adicionar um problema diretamente do Terminal
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(sons eletrônicos) - Qualquer coisa que o atrase é uma oportunidade de otimização. Agora, muitas vezes, para chegar a um repo, eu lanço um navegador. Então eu vou para esta página do GitHub, e então eu posso clicar em repositórios e, em seguida, fazer uma pesquisa para o repositório em que estou trabalhando. Neste caso, está bem aqui, mas pode ser muito abaixo da linha aqui. Então, geralmente eu acabo digitando algo aqui e à medida que os resultados do repositório surgem, eu clico no repositório que eu quero. E então eu posso ir para a guia de problemas para iniciar um novo problema. A questão é qual é a maneira mais rápida de criar um problema diretamente do terminal. Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode fazer isso. (sons eletrônicos) Agora, minha solução para isso é a CLI do GitHub. A CLI permite que você cuide de um monte de tarefas do GitHub, diretamente do terminal. Assim, você pode iniciar um problema enquanto trabalha em seu código. Agora, essa é uma ótima maneira de começar um a fazer ou criar um problema o mais rápido possível. Se você tiver o Homebrew instalado, você pode simplesmente executar uma instalação de fermentação, comando GH. Caso contrário, existem links no site que permitem que você baixe a CLI. Depois de instalá-lo, você terá todos os tipos de comandos adicionais do GitHub que você pode executar. Você pode começar usando o GH e, em seguida, emitir o comando create. Isso fará algumas perguntas para criar seu problema. Vou adicionar um título para este projeto. Eu vou clicar em return, e então você pode digitar um corpo aqui, mas como os corpos geralmente têm muito código e muitos textos, você também pode usar seu editor padrão aqui. Atom é o meu editor padrão. Então eu poderia simplesmente apertar a tecla e para abri-la, ou eu só vou apertar enter para pular. Agora, em seguida, você pode enviar o problema, mas pode adicionar mais metadados como faria diretamente no GitHub. Vou escolher adicionar metadados. Vou querer atribuir isso a mim mesmo e também adicionar alguns rótulos. E então eu vou bater voltar para ir em frente e começar. Agora, há apenas uma pessoa nesse projeto. Então eu vou atribuir isso a mim mesmo. E então, para rótulos, isso é documentação, bem como a ajuda desejada. Então eu vou apertá-los, apertar return, e então eu vou apertar o botão enviar. Agora isso é criado como um problema no meu projeto. Vamos dar uma olhada no GitHub. Vou para a guia de problemas e posso ver meu problema aqui mesmo com as tags apropriadas atribuídas a mim. Essa é uma maneira muito rápida de criar problemas, mas há muito mais que a CLI pode fazer. É muito bem pensado, e você pode fazer todas as coisas importantes que você pode fazer com o GitHub diretamente no terminal sem deixar seu código, o que deve economizar algum tempo no futuro.

Habilitar transcrições interativas


 Excluindo todo o histórico de commits
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(sons eletrônicos) - Git é uma ferramenta tão fantástica. E é uma ótima ideia se comprometer e enviar por push com frequência, porque é uma ótima maneira de armazenar alterações em um projeto na nuvem. Mas, ocasionalmente, gostaria de publicar uma ramificação no GitHub com um histórico de confirmação limpo. Como você excluiria todo o histórico de confirmação de uma ramificação existente no Git e no GitHub? Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode resolver algo assim. (sons eletrônicos) Agora aqui está o que eu faria. Você pode criar, o que é chamado de ramo órfão. Esta é uma ramificação que terá todos os arquivos na ramificação atual sem qualquer histórico. Vou começar emitindo um checkout git e usar a opção órfã aqui. E então eu vou chamar esse ramo de um ramo limpo. Agora você precisará adicionar uma confirmação aos arquivos no histórico. Observe que nenhum deles foi adicionado. Então, vamos em frente e fazer isso. Vamos dizer, git add -A, e então faremos um commit. Agora, essa ramificação vai substituir a ramificação principal do seu projeto. Então, vamos em frente e excluir isso. Embora isso funcione com qualquer outra ramificação que você esteja usando. Agora podemos pegar nosso ramo órfão atual e renomeá-lo para o nome do nosso ramo principal. Agora é hora de empurrar isso. Aqui embaixo, emitiremos um git push e usaremos a opção de força para forçar nosso ramo a ir diretamente em cima do ramo principal anterior. Isso empurrará todas as nossas alterações e, se voltarmos ao GitHub em nosso repositório, podemos dar uma olhada nas confirmações e ver que temos apenas um histórico limpo e estridente agora. Ramos órfãos são uma maneira bastante útil de manter as coisas limpas. Essa também é uma ótima maneira de redefinir as coisas quando você está brincando com o Git e o GitHub. Mas eu sugiro que você use um repositório privado para seus experimentos.

 Corrigir uma senha confirmada
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(sons de jogos de 8 bits) - Ocasionalmente, você pode acabar enviando uma confirmação ou um arquivo que tenha algumas informações confidenciais, como uma senha ou uma chave de API. Agora você não quer destruir toda a sua história, mas fazer uma mudança mais cirúrgica. Supondo que você tenha enviado um arquivo com uma senha e, em seguida, feito algumas outras confirmações. Como você garante que o GitHub não armazene essas senhas em seu histórico? Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode resolver isso. (sons de jogo de 8 bits) Tudo bem, há algumas maneiras de fazer isso. E no último vídeo mostrei como apagar todo o histórico de um projeto. Para este, precisamos ser mais cirúrgicos e vou usar um git regular para cuidar disso. Aqui está um projeto onde eu fiz uma série de commits. E se eu adicionar a opção de commits aqui no final, você pode ver que eu fiz um primeiro commit. Em seguida, adicionei meu arquivo de autenticação extremamente sensível. E então eu fiz alguns outros compromissos adicionais. Agora este arquivo também está no meu disco rígido atual. E se quisermos dar uma olhada nos commits, posso emitir o log do git e, em seguida, fazer a opção de uma linha. Eu continuo usando on-line em vez de oneline. Então, cuidado com esse pequeno E extra e você pode ver que ele tem os mesmos commits. Agora eu quero meio que me livrar desse commit como se nunca tivesse acontecido, mas primeiro eu preciso excluir essa autenticação extremamente sensível, arquivo dot js. Então, vamos em frente e nos livrar dele. Vou clicar com o botão direito do mouse e selecionar excluir, e então farei um commit para me livrar dele. Tudo bem, então se eu fizer o git log oneline novamente, você pode ver que eu tenho isso na minha história. Vamos em frente e empurrar isso. Então agora está no GitHub também. Queremos corrigir isso, então, para fazer isso, vamos fazer uma rebase interativa. Vou emitir uma rebase git com a opção interativa, e vou fazer uma cabeça e um til e colocar o número quatro aqui. Isso significa que queremos rebasear o repositório com a opção interativa e queremos trabalhar com os últimos quatro commits. Agora, isso deve acionar seu editor padrão. O meu é Adam, então isso é o que você deve obter em seu editor padrão. E você pode ver os commits aqui na ordem em que eu os fiz. Agora, o interessante aqui é que eu posso reorganizar esses commits em qualquer ordem que eu quiser. Então, o que eu quero fazer é pegar esse commit, fazer isso acontecer após a mudança original, o arquivo read me, você pode realmente colocá-lo em qualquer lugar. E então eu quero executar o commit imediato que eu fiz depois disso, onde eu apaguei esse arquivo sensível. Então, estou essencialmente modificando um arquivo, adicionando e excluindo eles. Mas não quero que esses compromissos permaneçam na história. Agora, há algumas maneiras pelas quais eu posso cuidar disso. Eu poderia fazer um commit de squash, que meio que mesclaria como um par de commits mesclaria esse commit no anterior, mas há um melhor chamado fix-up que fará a mesma coisa, mas em vez disso, ele só vai manter a mensagem de commit anterior. Para esses dois aqui, vou usar a opção de correção, e ela vai mesclar essas duas confirmações na anterior, e não vai armazenar nenhuma dessas mensagens de confirmação e ninguém saberá o que você fez. Então, vamos em frente e salvar isso. Vou fechar isso, voltar para o código do Visual Studio. Você pode ver que ele foi rebaseado e atualizado com êxito as referências. Agora vamos em frente e fazer um git log oneline novamente. E eu continuo dizendo online, então não se esqueça que E. E você pode ver que os commits agora desapareceram. Então eles não estão mais na história. Agora, o que eu preciso fazer é ir em frente e empurrar isso e eu vou precisar fazer um git push com uma opção de força. Então, ele vai substituir o que quer que seja no Github por qualquer coisa que eu esteja empurrando agora. E se eu fosse mudar para o Github e atualizar esta página com meu histórico de confirmações, você pode ver que agora isso se foi. É uma mudança permanente, por isso tenha cuidado. Você realmente não quer fazer isso com frequência em um histórico que é público, mas ocasionalmente você precisa remover arquivos e não deixar vestígios deles. E é assim que você faria.



Criar um monorepo
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
- [Instrutor] Quando seus projetos ficam maiores ou você simplesmente começa a criar muitos projetos que estão relacionados uns aos outros, você pode criar, o que é chamado de mono repo. Agora isso é um repositório gigantesco que tem todo o código para todos os seus outros repositórios nele. Ou você pode usar um determinado recurso que permite criar links simbólicos entre seus repositórios. Como você faria isso? Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode resolver isso. Os repositórios mono podem ser convenientes porque a atualização do código compartilhado entre os repositórios pode ser um pouco desafiadora, mas também pode ser difícil de gerenciar, já que a coisa toda está em um repositório gigantesco. Para isso, também podemos usar um recurso do Git chamado sub-módulos, que eu acho que é um recurso fantástico. Vamos começar criando um repositório no GitHub. Então eu vou usar o github.new e vou dar um nome a essa coisa. Vou chamá-lo de apresentações. E eu vou em frente e adicionar um arquivo leia-me a este repo. Agora, isso criará um repositório principal, mas para adicionar sub-repositórios a ele, precisarei cloná-lo em minha máquina local. Vou abrir o hiper app. Quero ter certeza de que estou na área de trabalho e vou emitir um clone git para clonar esse repositório no meu disco rígido. Agora podemos fechar isso. Vamos abrir isso no meu editor de código do Visual Studio. Para adicionar um submódulo, use o git submódulo add e, em seguida, a URL do repositório que você deseja adicionar aqui. Vamos voltar ao GitHub. E eu vou voltar para a tela do meu repositório e você verá que eu tenho um monte de repositórios diferentes que têm slides neles. Vou pegar esse repositório aqui mesmo e copiar a URL. Vamos voltar para o código do Visual Studio. Vou colar isso e você pode ver que algumas coisas interessantes estão acontecendo aqui. Se você olhar para o repo, há um arquivo de módulos git extra. Você pode ver que isso tem uma referência ao repositório original. Ele também copiou todo o repositório para esta pasta aqui mesmo. Então está agindo como um mono repo. Vamos em frente e adicionar outro. Vamos descartar este bootstrap cinco repo aqui. Vamos emitir o mesmo comando, mas vá em frente e cole este novo URL. Você pode ver que agora está adicionado aqui. Então, vamos em frente e comprometer isso e enviá-lo para o GitHub para que possamos ver o que ele fez. Tudo bem, vamos mudar para o GitHub, ir para repositórios e dar uma olhada nos novos repositórios de apresentações No GitHub, você não vê o conteúdo das subpastas, mas vê um link simbólico que o leva diretamente a esse projeto. Agora é importante observar que o módulo e o submódulo têm árvores de confirmação diferentes. Portanto, o comprometimento no repositório principal não afeta os sub-repositórios. Se você ainda não usou submódulos antes, é uma ótima maneira de gerenciar projetos relacionados em grupos. Você pode adicionar, compartilhar documentos no repositório principal e, em seguida, também usar projetos e outros recursos do GitHub para gerenciar todo o seu grupo.



Atualizar determinados branches
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(sons eletrônicos) - [Instrutor] É hora de acelerar um pouco as coisas. Agora, nada deixa os desenvolvedores mais irritados do que ter que fazer tarefas repetitivas. Gostaríamos de substituir tudo por um pequeno script. Então, digamos que você esteja trabalhando em um projeto e uma nova versão de alguma biblioteca que você está usando seja atualizada. Você tem mais de uma ramificação para a qual gostaria de enviar essas atualizações por push. Como você automatizaria algo assim? Vou lhe dar alguns segundos para pensar em como você faz algo assim. (sons eletrônicos) Agora, embora eu pudesse resolver esse problema em vários idiomas. Eu adoro usar scripts bash para esse tipo de tarefa. Está disponível na maioria das distribuições Linux. E como você verá em desafios futuros, ele funciona muito bem com ações. É um pouco peculiar para a programação, mas você vai se acostumar com isso muito rapidamente. Criei um arquivo na minha pasta inicial chamado get update branches.sh. Eu tenho isso aberto no meu editor. Vamos passar por cima disso linha por linha. A primeira é a linha clássica que aponta para onde o compilador bash está. Em seguida, criamos uma matriz para que possamos controlar a quais ramificações essas alterações podem ser aplicadas. Agora, se você está vindo de Javascript ou outra linguagem, observe que as matrizes em bash não estão separadas por vírgulas, mas por espaços e dentro de um parêntese, mas na verdade não importa se há ou não guias ou mesmo retornos de carro. Então você pode realmente formatar isso como quiser. Em seguida, faremos um loop e isso é feito aqui. A estrutura dos loops de script bash é um pouco estranha com uma instrução for com comandos do e done e observe a notação estranha em que temos que colocar a matriz, mas ela funciona. Em seguida, podemos emitir uma série de comandos. Agora é aqui que a bash brilha. Podemos digitar a mesma coisa que digitamos no terminal. Observe o uso da variável item aqui. Isso está se referindo a cada um dos itens à medida que passamos pela matriz, mas observe que ele tem um cifrão no início dele. Observe também que eu comentei essa linha aqui, para que você possa ver como impedir que a instrução seja executada. Se você não quiser, neste caso, você pode enviar todas essas alterações para o GitHub, mas vamos apenas confirmar as alterações e não enviá-las neste exemplo. Agora, uma vez que o loop é feito, você pode escrever mais algumas declarações. E se quisermos alguma saída adicional que será impressa no terminal, estamos fazendo isso com esta declaração de eco. Agora vamos dar uma olhada no nosso projeto no código do Visual Studio. Eu tenho meu projeto com as duas ramificações extras e movi novas versões do CSS e JavaScript para a minha ramificação principal. Então você pode ver este bootstrap bundled.min, bem como este outro mapa aqui é novo, bem como alguns dos arquivos no CSS. Para executar um comando shell, podemos abrir um terminal e certificar-se de que você está no diretório de projetos atuais. Então podemos chamar isso de script. Eu armazenei esse script no meu diretório home. Então eu vou dizer git-update-branches.sh. E foi muito rápido e fácil. Eu tenho vários scripts bash que automatizam diferentes partes do meu processo do GitHub. Eles são uma ótima maneira de cuidar de tarefas repetitivas e podem fazer praticamente qualquer coisa.

Habilitar transcrições interativas


 Processar todas as ramificações
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(gráficos trinl) - Usar o Bash foi muito divertido. Então vamos fazer outra. Agora, desta vez, quero que você tente passar por todas as ramificações de um repo, não importa quantas ramificações existam e, em seguida, copie uma determinada pasta em cada uma dessas ramificações para uma pasta em sua área de trabalho. Cada ramificação deve ir em sua própria subpasta. Então, vamos dar uma olhada no nosso projeto, e a pasta que deseja que você copie é esta pasta Build. Então eu espero uma pasta na sua área de trabalho e, em seguida, dentro dessa pasta, outra subpasta para cada uma das ramificações que temos. Nesse caso, temos esse recurso, esse ramo principal e essa atualização e, em seguida, dentro de cada uma dessas pastas, gostaríamos do conteúdo do que estiver nessa subpasta Build. Vou lhe dar alguns minutos para descobrir como você faria algo assim. (música techno de 8 bits) Agora este é muito mais difícil, mas é muito menos código porque você tem que descobrir uma maneira de obter a lista de todas as ramificações. Vamos dar uma olhada no arquivo. Eu o criei dentro da minha pasta de usuário e ele é chamado de git-backup.sh. Isso vai abrir em Adão. Vamos em frente e passar por isso linha por linha. Primeiro, é claro, é a linha Bash que mostra onde o compilador está e o que eu tenho aqui é um loop for como antes, mas em vez de criar uma matriz, estou usando o comando git branch e estou passando por ele com a opção list. Vamos realmente dar uma olhada no que isso faz. Então eu vou pegar isso, voltar para o meu terminal no editor, e eu vou colar isso para ver o que ele faz. Então, isso vai me dar uma lista de todos os ramos, e você quase poderia usar isso como a matriz, exceto por este pequeno asterisco. Eu realmente não quero copiar isso. Então, vamos voltar e dar uma olhada no meu código e você verá que o que eu fiz foi usar um pipe para depois passar um comando definido. Então, esse pipe vai agir como um filtro, e então ele vai executar uma expressão regular na minha lista de ramificações, e obter os nomes que ele retorna na lista de ramificações, mas exclua o símbolo da estrela, isso vai se livrar do símbolo da estrela. E então funciona como antes. Passamos por um loop, e o que estamos fazendo aqui é primeiro verificar cada uma das ramificações, eu armazeno esse nome de ramificação, para que então eu possa fazer um diretório na área de trabalho com esse nome de ramificação. Estou usando a opção P apenas no caso de a pasta não existir, o que será o caso na primeira pasta, e se ela não existir, então ela realmente criará essa pasta para nós chamada backup. Finalmente, vou copiar todos os arquivos que estão dentro da pasta Build, e é isso que esse método -R faz, ele faz isso recursivamente, então ele passa por todos os arquivos dentro da pasta Build dessa ramificação e os coloca na área de trabalho nessa subpasta de ramificação. Então, vamos em frente e executar isso. Vamos limpar isso e emitiremos um comando de shell e, em seguida, vá para a pasta Usuários e localize nosso arquivo. Git-backup.sh. Tudo bem, e deveria ter feito isso muito rápido. Vamos dar uma olhada na nossa área de trabalho. E se abrirmos essa pasta, você verá uma pasta para cada uma dessas ramificações, com o conteúdo de todos os arquivos que estavam nessa subpasta específica. Muito legal. Agora, eu tenho vários scripts Bash que fazem todos os tipos de coisas, e você pode criar qualquer um deles para automatizar todos os seus processos do GitHub.


 Executar auditoria de acessibilidade no push
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(música lúdica) - [Illustrator] Seria ótimo se pudéssemos executar alguns relatórios de desempenho e usabilidade sempre que alguém empurrasse algo para o nosso site. Mas como você faria algo assim? Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode resolver isso. (música lúdica) Para cuidar disso, estou usando o GitHub Actions. Eles oferecem uma maneira totalmente nova de processar e executar a automação em seus repositórios. Há algumas coisas que fiz com este repositório para prepará-lo. Primeiro, se você olhar para o código, eu mudei o nome do que costumava ser a pasta builds para a pasta docs. Para usar as páginas do GitHub, ele precisa ser chamado de docs. Eu também fui para as Configurações e, em seguida, fui para Páginas aqui mesmo, e certifique-se de que eu escolhi a ramificação principal, bem como a pasta de documentos como o lugar a partir do qual eu queria construir o site. Então, agora, você pode ver que o site é publicado neste URL. E se eu for lá, posso ver uma representação do meu site. É uma ótima maneira de publicar sites gratuitamente. Agora, feito isso, posso executar minha automação. Vou voltar para Ações e, em seguida, vou configurar um fluxo de trabalho para mim mesmo. Agora, ele fornece um exemplo de fluxo de trabalho, mas eu tenho um na área de transferência e vou linha por linha para que você possa saber o que estou fazendo. Agora, a primeira coisa que estou fazendo é dar a isso um nome para o fluxo de trabalho que será gerado no Lighthouse Report, e isso definirá quando esse fluxo de trabalho será executado. Eu quero que ele seja executado, quando alguém empurra algo para a ramificação principal, que você pode executá-lo em um momento específico, ou você pode executá-lo quando alguém faz um Pull Request, ou vamos apenas executá-lo sempre que alguém mudar o ramo principal. Agora, você pode listar uma série de trabalhos que deseja executar. E você também pode especificar em qual máquina deseja executá-los. Estou pedindo que ele execute uma cópia do sistema operacional chamado Ubuntu e execute-o na versão mais recente desse sistema operacional, então posso definir uma série de etapas que desejo usar. Agora, os dois primeiros passos aqui, são coisas que eu queria pré-instalar antes de começar a executar as coisas. Número um, eu queria verificar todos os meus arquivos. E isso está usando algumas ações que o GitHub criou para nós. E isso vai verificar todo o nosso projeto e, essencialmente, colocar o terminal na pasta que tem todos os nossos arquivos. Agora, eu quero instalar um módulo de nó adicional, então estou pedindo que ele também use a ação do nó de configuração aqui. E com essa ação, posso especificar uma versão do nó que desejo usar. Estou usando o Nó 14 aqui, mas você pode tentar algumas versões posteriores, e acho que elas funcionarão muito bem. Agora, a partir daqui, também posso especificar um nome para uma série de etapas que desejo executar. Agora, essas guias são essencialmente o que aconteceria se eu executasse esses comandos diretamente no meu terminal. E aqui, eu executo um comando run, e este pipe diz que eu quero executar um número de linhas. Se você não sabe o que é esse formato, ele é chamado de YML e é uma maneira especial de formatar seu código. E nesta versão, as abas ou o espaçamento são relevantes aqui. Então, todas as linhas que eu executo aqui são o que vai executar sempre que chegar a esse comando. E estes são exatamente o que você precisaria digitar se estivesse fazendo as coisas a partir do seu terminal. Então, primeiro, porque eu quero ter certeza de que o Lighthouse está instalado nesta cópia do Ubuntu, eu estou indo em frente e executando um comando de instalação NPM, e ele vai instalá-lo globalmente. E o módulo de nó que eu quero usar é o Lighthouse. Agora, você pode ter visto o Lighthouse quando inspeciona um site no seu navegador. Geralmente está na última guia à direita. Então, em algum lugar por aqui, você pode notar que há essa coisa chamada Farol, e ela fornece diferentes relatórios que você pode usar para avaliar como seu site está indo. E o que queremos fazer aqui, é executar isso sempre que alguém empurra algo para o nosso site, e então dar uma olhada nesse relatório imediatamente. Então, estamos executando este comando Lighthouse depois que ele é instalado. E então estamos especificando uma URL. Agora, aqui, preciso especificar a URL do que estou executando. Então, se você se lembra, vamos rebel.org, e então vamos para este site chamado Parallax. Agora aqui, também posso especificar algumas bandeiras que quero executar. Agora, normalmente, quando você executa isso a partir do terminal, ele realmente abrirá um navegador para mostrar os resultados. Nesse caso, estamos executando isso nos servidores GitHub. Então, não haverá um navegador nesses servidores para eu olhar, então estou executando-o sem cabeça, o que significa que não o execute em um navegador. Também posso especificar como será este relatório. E neste caso, eu quero escolher JSON. O padrão é HTML, e é um pouco difícil de ler em um terminal. Finalmente, também posso especificar o caminho de saída. Isso colocaria o relatório em um arquivo chamado relatório. JSON. Lembre-se, tudo isso vai acontecer em uma máquina que nem vamos ver. Vamos apenas ver os resultados da máquina. Então, o que eu quero fazer é apenas exibir esse arquivo depois que ele for criado. Então, vamos em frente e começar o commit aqui. Vamos apenas clicar neste Commit New File que realmente vai gerar um push para a minha ramificação principal. Então, se eu for para Ações, poderei ver essa ação em execução. Vamos em frente e abrir isso. Então, nós apenas clicamos nisso. Você pode ver que o processo de compilação está acontecendo, vamos clicar nisso. Você pode realmente ver a ação em execução à medida que ela passa pelas diferentes etapas que especifiquei. Quando ele conseguir obter o relatório, você verá que ele vai instalar o nó. Vai baixar nosso projeto nessa máquina. E então, no final, você verá um relatório sendo gerado a partir da instalação do Farol. E correu ali mesmo. Depois de tudo o que isso aconteceu, vai meio que fechar tudo. Mas você pode chegar ao relatório abrindo esse tipo de triângulo aqui mesmo e percorrendo tudo isso. Este relatório é muito grande, então eu não sei se você quer olhar para ele. E você provavelmente gostaria de configurá-lo um pouco mais se quiser mais detalhes, ou se quiser que ele seja executado apenas, digamos, o relatório de acessibilidade, é bastante flexível. A coisa importante a notar é que eu estou realmente executando comandos de terminal e deixando o GitHub fazer isso por mim toda vez que alguém empurra algo para este repositório que eu tenho aqui.




Use segredos ocultos em projetos
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(música eletrônica) - [Ray] Ao trabalhar com projetos, é realmente importante ser capaz de armazenar um determinado IDs, variáveis e senhas especiais com segurança. Agora, para este desafio, quero que você armazene um segredo no GitHub e o recupere usando ações do GitHub. Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode ter resolvido algo assim. (música eletrônica otimista) Agora, para armazenar um segredo no GitHub, você precisará acessar sua conta. Em seguida, você precisará encontrar um repositório ao qual deseja adicionar um segredo. Estou usando este repositório Parallax e ele foi limpo do vídeo anterior. E aqui, clique em configurações e, em seguida, procure a seção chamada segredos. Você pode ver que eu já tenho um segredo aqui. Para criá-lo, posso simplesmente clicar no novo segredo do repositório. Dê um nome ao segredo. Eu já chamei a minha chave de API do Google. E, em seguida, cole sua API ou seu segredo aqui mesmo nesse valor. Agora, você não poderá ver o valor desse segredo novamente, então poderá removê-lo ou atualizar o segredo, mas não poderá ver o que foi armazenado lá. E isso é ótimo para quando você está trabalhando com muitas pessoas e quer que elas tenham acesso a uma API com uma chave compartilhada, mas você não quer que elas saibam o que é essa chave. Agora vamos entrar em ações, e vamos criar um novo fluxo de trabalho aqui. E nós mesmos vamos configurar isso. E criaremos um novo fluxo de trabalho para ir em frente e usar esse segredo de maneira prática. Então eu vou colar um pouco de código, e então eu vou linha por linha através dele para que você possa entendê-lo. Vou substituir o que está aqui. E você pode ver que eu dei um nome a essa coisa para que o fluxo de trabalho seja executado com esse nome. E então eu estou pedindo que ele vá em frente e corra sempre que alguém empurrar para o ramo principal. Agora, aqui, enviamos uma série de trabalhos. E o trabalho que queremos executar será executado em uma máquina específica chamada Ubuntu Latest. Esse é o sistema operacional Ubuntu e a versão mais recente disso. Agora podemos fazer uma referência à chave que armazenamos. Estamos dizendo que isso vai usar nossa chave de API do Google que armazenamos em nossos segredos. E então definimos uma série de etapas. Agora, aqui, queremos usar pelo menos a ação de checkout que o Google fornece para nós. Isso garantirá que o código que eu executar aqui terá acesso aos arquivos no meu repositório. Agora eu posso executar uma série de etapas. E é uma boa ideia dar um nome às etapas, porque você pode ter mais de uma série de etapas. E aqui, então alguns chamando este, obter a lista de fontes. E eu vou executar um comando de terminal. Então, esta execução aqui significa que o seguinte será executado como se eu estivesse digitando-os a partir do terminal. E começa com um caractere de pipe porque eu vou incluir mais de uma linha. Então você notará que as primeiras coisas que estou fazendo aqui é configurar o arquivo get config para que ele tenha um nome de usuário, bem como um e-mail. Isso é importante porque o GitHub vai criar uma máquina para você. E a primeira vez que você criar, ou usar o GitHub em uma máquina, ele vai querer que você configure o nome de usuário e a senha. Estamos usando as variáveis de ambiente. Portanto, o ator do GitHub significa a conta que está executando essa ação. E, em seguida, o e-mail de entrada será o e-mail dessa conta. E você precisará incluir ambos. Agora, aqui, estamos usando um comando curl. Então, estamos usando as APIs do Google e as fontes da Web, especificamente a versão um. E aqui, estamos executando este aplicativo de fontes da Web. Estamos passando uma chave. Agora, normalmente, você estaria colando a chave fisicamente aqui, mas podemos pedir que ela procure nos segredos a chave da API do Google que geramos anteriormente. Vai levar os resultados desta declaração de ondulação, que é algo que você pode digitar no seu terminal. Ele vai recuar isso para um arquivo que ele chamará de fontslist.json Esse é um arquivo que agora estará neste repositório, mas não existirá no GitHub, a menos que o confirmemos e o empurremos de volta para o GitHub. Portanto, precisamos fazer um git-add, bem como um git-commit. Então você pode ver que estou combinando essas afirmações. Vou dar-lhe um nome aqui chamado lista de fontes atualizadas. E então eu estou empurrando isso de volta para o GitHub para que ele apareça como um arquivo no meu repositório. Então, vamos em frente e começar este compromisso. Vamos confirmar este arquivo. Então, agora que o fluxo de trabalho é criado, vamos para as ações. E queremos ir em frente e clicar em todos os fluxos de trabalho e, em seguida, escolher o fluxo de trabalho que queremos executar, que será essa fonte favorita do Google. Clicaremos no fluxo de trabalho. Assim, você pode ver que ele executou o fluxo de trabalho e foi bem-sucedido em fazer todas as ações. Então você pode dar uma olhada em obter a lista de fontes. E você pode ver que ele criou um arquivo chamado fontslist.json Agora, se voltarmos ao código, você deve ser capaz de ver esse arquivo aqui. E isso tem o arquivo JSON dos favoritos das fontes do Google. A capacidade de fazer algo usando ações no GitHub, e ter isso gerar um arquivo usando um segredo é bastante impressionante. Tenho certeza de que você já está pensando sobre o que mais você pode fazer com essa técnica.

Habilitar transcrições interativas




Executar ações em um agendamento
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(música eletrônica triunfante) - [Ray] Você tem que obter ação de hub, e você quer ter certeza de que ele é executado não apenas uma vez, ou quando os usuários empurram algo para o seu repo, mas todos os dias às 8:30 da manhã. Como você faria algo assim? Agora vamos dar-lhe alguns segundos para pausar o vídeo e ver como você pode ter resolvido algo assim. (melodia eletrônica brilhante) Agora, para este exemplo, vou usar a ação que fiz no vídeo anterior. Então, vamos entrar neste arquivo de fluxo de trabalho e vamos modificá-lo um pouco. Então você pode ver aqui que isso mostra que isso será ativado quando alguém empurrar para o nosso ramo principal. O que queremos fazer é executar isso em um cronograma. Então, vamos dizer programação aqui. E então, na próxima linha, colocaremos um traço e a palavra cron, com dois pontos e, em seguida, uma corda. O que eu quero fazer aqui é 30 e depois o espaço 8, e depois uma série de três estrelas. E vamos fechar essa citação ali mesmo. Se você rolar sobre isso, ele lhe dirá que isso será executado às 8:30 UTC todos os dias. Agora, as ações também podem ser executadas no máximo cinco minutos. Se você quiser personalizar isso, você pode usar um número de caracteres especiais diferentes, e um ótimo lugar para ir para obter informações sobre como usá-los é ir para o site chamado crontab.guru, onde você pode brincar com as diferentes configurações. Então você pode ver que, se tivermos, vamos fazer 30 estrelas estrelas de 8 estrelas, assim como tínhamos antes. Então, isso vai acontecer às 8:30, mas se quisermos, podemos dizer 0,1 aqui. E agora isso vai funcionar no domingo e na segunda-feira. Assim, você pode especificar dias diferentes colocando os valores aqui. Você também pode fazer um intervalo de valores. Então você pode dizer de um a cinco. Então, este vai funcionar de segunda a sexta-feira apenas. E você também pode percorrer uma série de valores. Então, se você quisesse, você pode dizer algo como zero e depois. Então, isso será executado a cada 15 minutos de 0 a 59. Então, a cada 15 minutos, em outras palavras, você pode usar algo tão curto quanto zero a cinco. Então isso vai ser executado a cada cinco minutos, e lembre-se de que há esse limite de tempo que você pode usar. Então, se você queria usar algo assim, então você apenas, vamos em frente e colocar 30 de volta aqui. Basta copiar a partir daqui, e então você pode voltar para o seu repositório e colar isso em sua ação. E você quer ter certeza de que você rola aqui para se certificar de que você tem o que você precisa. Agora, o crontab existe há muito tempo. É uma ótima maneira de definir tarefas e ações repetitivas que você deseja executar. É incrível que uma simples variável cinco possa permitir que você defina praticamente qualquer cronograma de implantação que você possa imaginar.

Habilitar transcrições interativas





Criar uma ação de contêiner do Docker
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(música divertida) - [Ray] As ações são ótimas, mas a sintaxe para executar comandos pode ser um pouco limitante. Além disso, eles são um pouco difíceis de compartilhar. Assim, você pode criar Ações mais explicitamente usando contêineres do Docker e, em seguida, fazendo com que eles executem seus Shell Scripts. Mas como você faria algo assim? Agora, vou lhe dar alguns minutos para pensar em como você pode resolver algo assim. (música lúdica) Agora, você pode dar uma olhada em um exemplo de como fazer isso nesta ação que eu criei chamada copy-to-branches. Você pode reconhecer que esse código é semelhante ao que estávamos fazendo quando estávamos criando um dos scripts bash. A diferença é que nosso script bash não estará nesse arquivo chamado entrypoint.sh. Agora, temos que adicionar alguns arquivos adicionais. Este é um repositório bastante normal com uma licença README, bem como o arquivo gitignore. Mas o resto dos arquivos que você vai precisar, comece com este arquivo action.yml. Agora, aqui você pode ver que estamos dando um nome a essa ação e, em seguida, estamos dando alguns dados gerais aqui com meu nome e a descrição do que isso faz. E vamos dizer que isso é executado usando um arquivo do Docker, que explicaremos em apenas um minuto. E ele precisa de uma marca distinta chamada para que, quando você a vir no GitHub Marketplace, ela apareça com um determinado ícone e em uma cor específica. Agora, você também pode especificar aqui, certas entradas que você pode usar em seus scripts. Então, isso parece muito semelhante ao que você cria quando faz uma ação. Também é um arquivo YML como uma ação normal do GitHub, mas é o que identifica os componentes dessa ação específica e mais complexa. Então, voltaremos para as páginas de cópia e, em seguida, daremos uma olhada no arquivo do Docker, porque essa é a próxima coisa que carregaremos quando essa ação for executada. O arquivo Docker é um documento que especifica a máquina que você deseja usar e como ela será configurada. Agora, observe que estou usando um tipo de máquina chamada Alpine. Eu tenho usado algo chamado Ubuntu Linux. Agora, o Alpine é muito mais rápido do que o Ubuntu Linux, que é o que a maioria das pessoas usa quando está trabalhando com o Actions. Você pode ver que estou executando alguns comandos em estoque aqui e aqui, porque quero ter certeza de que essa máquina vem pré-instalada com o Git e também instalada com o Bash, que é o tipo de script que vou usar. Agora, aqui, eu estou copiando outro arquivo que veremos em apenas um segundo chamado entrypoint.sh, e ele será armazenado na pasta para a qual minha máquina será aberta, e também será chamado de entrypoint.sh E então, nós meio que iniciamos esse ponto de entrada com esse comando de ponto de entrada, então vamos dar uma olhada nesse próximo. Então, aqui está o meu Shell Script real. Você pode notar que é semelhante aos que temos feito antes. Obviamente, é muito mais longo, e você pode ver isso aqui, estou configurando o GitHub, porque quando você estiver executando essa máquina, ela será como uma nova máquina de bebê. E a primeira coisa que você faz quando recebe uma nova máquina é configurar o e-mail do usuário para o Git, bem como o nome do usuário. Agora, é assim que eu repasso valores dos meus scripts para essa ação aqui. Então, se você se lembra do que estávamos fazendo antes, estávamos passando informações usando a extensão do terminal. Então, executamos um comando de terminal e, em seguida, adicionamos alguns argumentos. Aqui, eles se tornarão de outra ação que estará no repositório do qual estamos chamando isso. O resto será apenas um código praticamente normal que você viu em um dos vídeos anteriores. Ele vai criar variáveis diferentes com os argumentos que são passados e, em seguida, vai pegar todos os arquivos e listá-los. O código é bastante complicado aqui, mas está fazendo muitas das mesmas coisas que estava fazendo antes. E o interessante é que ele está executando isso como um projeto separado. Deixe-me mostrar-lhe, uma vez que você tenha todos esses arquivos criados, então o que você faz, é que você pode criar uma série de versões que tornarão isso disponível no GitHub Marketplace. Então, se clicarmos em View On Marketplace, você pode ver a ação aqui. E para usar essa ação em um repositório separado, basta clicar em Usar esta versão mais recente aqui. Você pode copiar parte do código. Essa ação em particular tem muitas informações sobre como ela está configurada, um arquivo README realmente bom. Portanto, este é um ótimo projeto inicial para criar sua própria ação que você pode compartilhar com outras pessoas sem ter que apenas enviar-lhes uma grande ação, esse arquivo YML. Agora, você pode criar Ações muito mais poderosas usando esse método do Docker. É um pouco mais trabalhoso, mas realmente vale a pena, já que é um repositório real que você também pode usar e colaborar com outras pessoas.



Crie e implante seus sites
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
(sons eletrônicos) - [Instrutor] O típico projeto web moderno tem diferentes tipos de processos construídos para desenvolver, testar e construir seus aplicativos. Você pode implantar sites e aplicativos estáticos usando o GitHub, mas como você deixaria o GitHub ajudá-lo a executar esses processos e implantar sites em seus servidores? Vou dar-lhe alguns segundos para pausar o vídeo e pensar em como você pode resolver algo assim. (sons eletrônicos) Agora, embora você possa escrever sua própria Ação do GitHub usando o que aprendeu até agora, às vezes vale a pena procurar no GitHub Marketplace e encontrar uma ação que faça isso por você. Agora, meu site pessoal, que é raybo.org usa uma ação, assim como esta, para criar e implantar o site, usando páginas do GitHub. Vamos dar uma olhada no arquivo de ação que eu uso, e você pode ver que eu o executei muitas vezes aqui. Então eu vou abrir isso e você pode ver que não há realmente muito código aqui, e eu estou usando algo semelhante ao que eu fiz em vídeos anteriores. Estou criando uma ação que tem um nome. Eu chamo isso de Build and Deploy, e isso será executado automaticamente sempre que eu enviar algo. Este é o meu blog. Então eu sou a única pessoa trabalhando nisso. Sempre que eu empurrar qualquer coisa para o mestre, isso executará automaticamente essa ação. Agora, aqui especificamos o tipo de sistema operacional em que queremos executá-lo. Estou usando o Ubuntu mais recente e, em seguida, uma série de etapas que eu quero executar. Então, aqui, eu quero ter certeza de que eu uso, e eu estou chamando essa etapa aqui chamada checkout, e aqui, eu vou usar a ação de checkout que o GitHub fornece para mim. E então eu vou executar uma série de comandos de instalação e compilação. Agora, isso vai executar uma instalação do NPM e uma compilação de execução do NPM. Então, isso é exatamente o que eu executaria na minha máquina local, exceto que estou fazendo isso em servidores GitHub. Estou instalando os módulos para o meu processo de compilação e, em seguida, estou executando um processo de compilação logo em seguida. Agora, a ação que estou usando é essa ação aqui de James Ives. Chama-se páginas do GitHub, ação de implantação. E eu estou usando uma versão específica ou uma versão lá. E eu estou apenas dando essa coisa, o nome deploy. E aqui, o que eu digo é que eu quero executar com alguns parâmetros, número um, a ramificação que eu quero que ele crie quando isso for implantado. E também a pasta a partir da qual ele está construindo. Então, quando eu executar a compilação de execução do NPM, ela criará uma pasta de compilação para mim. E então ele vai gerar uma ramificação chamada root e colocar o conteúdo da pasta de compilação que ele está gerando nessa ramificação raiz. Com certeza, se formos para a seção de código aqui, podemos ver que há uma ramificação chamada rota. E se eu clicar nisso, parece um site normal. Ele tem apenas o conteúdo da página da Web. Então, isso significa que sempre que eu entro aqui e faço uma modificação no meu site, ele automaticamente executa um processo de compilação, gerando uma ramificação, que estamos chamando de rota e implantando os resultados das minhas compilações. Isso também poderia ser testes e criação do site para mim, que então se parece com isso. Agora, os sites estáticos como este são bastante fáceis e geram uma ramificação separada para suas implantações. Normalmente, eu poderia fazer isso implantando uma pasta de documentos na rota, mas é bom poder procurar ações e você pode fazê-lo no GitHub Marketplace e encontrar toneladas de outras ações que você pode usar que as pessoas escreveram para você. Você também pode criar o seu próprio, assim como eu mostrei no último vídeo.
