 Intro
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Olá! Seja muito bem-vindo e muito bem-vinda ao curso "Formação Básica em GitHub Actions", a ferramenta de automação e DevOps do GitHub. Me chamo Júlio Arruda, sou Microsoft MVP em Developer Technologies há sete anos, e também o primeiro GitHub Star aqui do Brasil. No ciclo de desenvolvimento de software, automações são essenciais para o sucesso dos nossos projetos. Então venha neste curso se aprofundar em uma das principais ferramentas do mercado, o GitHub Actions, e dê uma guinada em seus projetos corporativos ou pessoais com essa fantástica ferramenta.


O que é GitHub
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
O que é o GitHub? Você já ouviu falar dessa plataforma? O GitHub, ele é uma plataforma muito completa que aborda todo o ciclo de desenvolvimento de software. E quando eu estou falando que é todo o ciclo de desenvolvimento de software é porque vai desde a base até deixar a sua aplicação ali em produção. As principais funcionalidades, hoje, que nós temos dentro do GitHub, a principal delas, eu diria, é a parte de repositórios de código fonte. Aqui provavelmente é pela qual a ferramenta ficou muito conhecida em todos esses anos, porque ela principalmente hospeda códigos tanto privados quanto públicos, com grande foco em repositórios públicos, porque é dentro do GitHub que você encontra a grande maioria de repositórios de projetos open source. Ok? Então, aqui dentro do GitHub, nós podemos hospedar projetos públicos, como já bem conhecemos, mas também repositórios privados para projetos que você não gostaria de compartilhar com outras pessoas na internet. E isso vale para seus repositórios, tanto de uso pessoal quanto de uso corporativo. Outra funcionalidade que nós temos aqui dentro do GitHub é a parte de gestão de demandas e projetos, porque quando estamos trabalhando com o desenvolvimento de software, uma questão muito importante é gerenciarmos demandas, gerenciarmos backlogs, novas features que estão em desenvolvimento. E aqui dentro do GitHub nós também temos esta possibilidade com uma função muito bem desenvolvida, que está em constante evolução, chamada GitHub Projects. A gente também tem aqui a parte de desenvolvimento de software. E por que que eu estou falando do desenvolvimento de software? Bom, aqui nós temos a possibilidade de utilizar uma IDE de desenvolvimento completa dentro do ambiente do GitHub, ou seja, sabe o seu VSCode que você instala dentro da sua máquina hoje, configura para o seu ambiente de desenvolvimento, instala seus SDK, instala seus componentes, suas extensões para você começar a desenvolver? Hoje você pode utilizar isso dentro do ambiente do GitHub, em nuvem, a partir de qualquer navegador e a partir de qualquer dispositivo. Por exemplo, se você tiver um tablet, você consegue trabalhar desse tablet, porque todo o processamento não está no seu dispositivo, está na nuvem, num container hospedado pelo próprio GitHub, com acesso completo à build debug da sua aplicação. Nós também temos aqui a possibilidade de publicação de pacotes dentro do GitHub com o GitHub Packages. Aqui nós podemos publicar pacotes NuGet, NPM, Maven ou até mesmo imagens Docker das nossas aplicações, seja para publicar isso de maneira privada, dentro da nossa organização ou com pessoas das quais você dá acesso, ou com repositórios públicos e projetos open source. Outro ponto que eu acho muito interessante, e é o foco do nosso treinamento, é que também temos uma funcionalidade focada em DevOps e automação, que é o GitHub Actions, que permite que nós façamos uma série de automações dentro dos nossos projetos que nós vamos ver no decorrer deste nosso curso.

Habilitar transcrições interativas

 Explore o GitHub
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos agora então dar uma explorada no site do GitHub. Para isso, basta você acessar o mesmo site que estou acessando neste momento, github.com, e você vai cair em uma muito similar a essa aqui. E essa página, ela é bastante interessante por quê? Bom, no menu inicial superior nós podemos ver alguns links, como o primeiro deles sendo a parte de produtos, onde nós podemos encontrar redirecionamentos para os principais produtos do GitHub. Como, por exemplo, o Actions, Packages, Codespaces, Copilot, entre outros. O próximo menu é a parte de Solutions, onde nós podemos encontrar questões para empresas, times, startups, soluções de DevOps, entre várias outras coisas interessantes, como Learning Pathways, E-Books e Webinars. O próximo que entramos é o de Open Source, onde nós podemos visualizar informações voltadas a essa questão, como projetos de Sponsors ou projetos The ReadME Project, que traz vários arquivos de comunidade. É bastante interessante você acompanhar isso também. No menu subsequente, entra a parte de Pricing, onde você pode entender quanto custa usar o GitHub nos seus projetos. E também nós temos uma busca para encontrar e obter mais informações sobre repositórios, projetos e produtos do GitHub. Indo ao lado, nós temos dois links: o primeiro deles sendo o Sign In. Este é o link para você realizar o seu login, caso você já possua uma conta no GitHub. E ao lado de Sign In, nós temos um botão chamado Sign up. Neste caso, serve para caso você ainda não tenha uma conta no GitHub, para que consiga criar a sua conta. Nós vamos fazer isso em breve, não agora. Vamos continuar dando uma olhada no site. Descendo um pouco aqui, nós podemos visualizar algumas informações, como o texto inicial do site, que é "Let's build from here, the world's leading AI-powered developer platform". Basicamente aqui diz para você começar a desenvolver e construir seus sites por aqui, suas aplicações por aqui, e que o GitHub é a plataforma líder em desenvolvimento com AI. Ok? Descendo um pouco mais, nós temos uma caixinha de texto onde nós podemos colocar o nosso e-mail e também realizar o Sign Up para o GitHub. E ao lado dessa opção nós temos também um outro botão, que é o Start a Free ENTERprise Trial, que, ou seja, se você estiver buscando criar uma conta ENTERprise, você pode começar com o Trial clicando então. Descendo um pouco mais a tela, nós temos algumas das principais empresas que acreditam no GitHub, como 3M, KPMG, Mercedes, SAP, entre algumas outras também. Descendo para baixo, conseguimos ver uma questão muito importante de produtividade, onde nós podemos acelerar a inovação usando inteligência artificial para poder melhorar o processo de desenvolvimento. E descendo ainda um pouco mais, aqui nós temos a opção que nos interessa neste nosso curso, que é o GitHub Actions, onde você pode descobrir tudo sobre o GitHub Actions clicando no link que ele expõe nesta opção. E você também pode visualizar uma tela com alguns Pipelines em execução, alguns logs de Pipelines. E no final dessa página, nós podemos visualizar que hoje mais de 100 milhões de pessoas desenvolvedoras chamam o GitHub de casa. Isso é muito importante que nós podemos visualizar como muita gente usa e acredita no GitHub. E aqui nós encerramos o nosso pequeno curso sobre GitHub.


 Como criar uma conta no GitHub
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Então agora vamos criar a nossa conta aqui no GitHub. Para isso, nós podemos fazer isso de duas formas. A primeira delas, vindo no menu superior clicar em Sign up, ou a que eu acho muito mais prático e mais divertido, vir aqui no meio da tela nesta caixa de endereço de e-mail e colocar o seu endereço aqui. Eu vou colocar o endereço de e-mail temporário, porque eu já tenho a minha conta no GitHub, então eu vou criar aqui a minha conta com o meu e-mail temporário. Vou colocar aqui julio.arruda+demolinkedin001@outlook.com e vou clicar aqui em Sign up para o GitHub. E aqui o processo agora continua nessa nova tela que se carregou. Nessa nova tela que foi carregada, temos um fundo aqui meio espacial que eu acho muito bacana, e aparece um quadrado no meio da tela com boas vindas ao GitHub. Vamos iniciar a nossa aventura! E uma caixinha para "Entre com o seu e-mail" e vai pegar o mesmo e-mail que nós colocamos anteriormente, ok? Mas aqui você ainda pode customizar, caso tenha colocado o endereço incorreto, mas eu vou clicar no botão Continue, ao lado. E logo abaixo vai aparecer uma opção para criar a nossa senha. Eu vou criar uma senha aqui. Você pode fazer o mesmo. Pode não, deve fazer o mesmo. E aqui aparece logo abaixo uma mensagem informando se a sua senha é difícil ou não. Para garantir isso, ele pede uma senha com 15 caracteres ou oito, incluindo letras, números e caracteres especiais. Se eu colocar uma senha simples, por exemplo, eu vou deletar essa aqui. Vou colocar aqui um, dois, três, quatro, cinco, seis. A senha é muito curta. Sete, oito. A senha precisa de números e caracteres especiais, então ele vai entendendo a dificuldade da sua senha, a complexidade da sua senha, para garantir que você está criando uma senha segura. Vou clicar aqui agora em Continue, e agora nós precisamos definir o nosso usuário no campo que apareceu abaixo, que pede justamente entre com seu Username. E por que esse Username, ele é tão importante? Porque basicamente qualquer coisa que você for fazer no GitHub vai estar atrelado a este seu Username. Tudo, a sua conta, qualquer coisa, rastreabilidade, tudo atrelado a este Username. Por exemplo, eu posso colocar o meu aqui, julioarruda, que é o que já existe na minha conta, mas ele não permite isso. Por quê? Porque o Username é de uso único e exclusivo. Então, como eu já tenho uma conta com julioarruda, outra pessoa não pode ter uma conta com o mesmo nome. Para eu usar aqui julioarruda, por exemplo, eu preciso fazer uma modificação, complementação nesse Username para que seja identificado como Username diferente, ok? Então, você precisa pensar no seu Ussername e criar o seu Username específico dentro do GitHub. Eu vou colocar aqui julioarrudalinkedin001, e esse Username está disponível. Eu vou aqui, continuar. A mensagem abaixo aqui diz que você pode escolher receber updates e anúncios via e-mail. Você pode colocar Y para sim, que seria Yes, ou N para não, que seria No, em inglês, mas aqui no meu caso eu vou colocar N, porque eu já tenho a minha conta no GitHub nesse mesmo e-mail, que aqui eu tô só usando o e-mail temporário, mas eu recebo nesse mesmo e-mail. Então vou colocar como não, porque eu já recebo isso. Clico em Continue. E agora aparece uma opção para verificar a nossa conta. É um Captcha diferente. Precisamos clicar primeiro aqui nesse botão Verify, mas ele é um Captcha diferente, porque eu não preciso ficar digitando textos. Basicamente, eu preciso ver uma imagem que é mostrada no canto direito e outra imagem no canto esquerdo, eu preciso deixar no mesmo direcionamento, porque a da direita é uma mãozinha apontando para um lado e eu preciso mexer no animalzinho para que aponte para o mesmo lado. Então, eu vou virar aqui. Acho que estou no mesmo lado. Clico em Submit. Aparece... dessa vez foi um só, mas, as vezes, aparece duas, três vezes para isso ser feito. Dessa vez, uma vez só. E é só criar a minha conta. E agora aqui acontece uma questão bem importante para validar que você realmente é você, além daquele Captcha. É enviado um código para o seu e-mail para que você digite aqui. Deixa eu ver se eu recebi e deixa eu digitar o meu código aqui. E agora é isso. Agora nós vamos partir para o próximo passo de personalização do nosso GitHub.


 Personalize sua conta no GitHub
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Agora que nós criamos a conta, vamos então personalizar a nossa conta aqui no GitHub. Essa opção, ela não é obrigatória, ok? Você pode simplesmente vir aqui, clicar nesse botão na parte de baixo da tela e pular a personalização, mas às vezes é importante para que você entenda algumas questões do GitHub, que ele mostra no decorrer dessa personalização. Primeiro, na caixinha aqui ao lado nós temos qual é o tamanho do time que vai trabalhar com você, se aí você está criando uma conta só para você, se está criando voltado para uma empresa. Então, tem aqui Just Me, 2 a 5 pessoas, 5 a 10 pessoas, 10 a 20, mais de 50. Eu vou colocar apenas eu. Aqui embaixo nós temos uma opção perguntando se você é estudante ou professor. Você pode marcar qual dos dois se enquadra para você. Eu vou marcar como nenhuma dessas opções, e vou clicar no botão de Continue que aparece também nessa mesma caixa em branco. Agora carregou uma nova tela e, ao lado, tem também uma outra caixa em branco, como na tela anterior, e está perguntando aqui: "Quais as Features você está interessado em utilizar?" E aqui nós podemos encontrar como ferramentas de colaboração, que são Codespaces, Pull requests, notificação, processo de Code Review, Code Owners, e essas questões mais voltadas a repositório e colaboração. Eu vou clicar nela aqui. Abaixo, nós temos a parte de automação e CI/CD, onde encontramos Actions, Packages, GitHub Pages, GitHub Marketplace, Hosted Runner, Self-hosted Runner, Secrets, entre outras coisas. Vou marcar esse também. Abaixo, nós temos aqui Security, para repositórios privados, Multifactor Authentication, revisores obrigatórios, Status Check obrigatório, escaneamento de código, escaneamento de Secrets, gráfico de dependências, Dependabot, que também é bastante legal, é importante. Se você estiver voltado a um uso corporativo, também pode marcar aqui que você quer saber mais sobre questões de segurança ENTERprise, como o SAML, LDAP, bloqueios por IP, Log de auditoria. Nós também podemos ver aqui um pouco mais abaixo Client Apps, como o GitHub, Mobile, GitHub CLI, e GitHub Desktop. Descendo um pouco mais, nós temos a parte de gestão de projetos, como Project Labels, Issues, Milestones, Wikis, entre outras coisas. Mais abaixo, nós temos aqui também administração de times. Caso você tenha uma Conta Time, você pode adicionar pessoas, adicionar verificação de domínios, logs de auditoria, restrição de repositório de criação de repositório e também temos a parte de comunidade aqui embaixo, que é para o GitHub Marketplace, Sponsors, Skills e outras coisas. Eu vou clicar agora aqui em Continue, e carregou uma nova tela. Ok? Nessa nova tela agora, ele... como eu marquei aquela questão do ENTERprise, ele está me sugerindo aqui falando que o GitHub ENTERprise é o melhor para mim. Então ele está me recomendando ou usar a camada gratuita ou usar a camada ENTERprise. Isso baseado nas personalizações que eu trouxe para mim. Isso aqui é interessante, porque nós podemos ver que o GitHub entende qual que é a melhor opção para você e te sugere usar isso, mas não de forma obrigatória. Você pode simplesmente vir aqui no menu ao lado que onde diz Free, que é a parte gratuita, e usar esta camada e ela já é muito útil para a gente. Se você olhar aqui, a parte inicial, o primeiro menu que ela tem, diz: ilimitados repositórios públicos e privados. Ou seja, se você criou uma conta no GitHub gratuitamente, não importa quantos repositórios você tenha, sejam eles públicos ou privados, você vai conseguir utilizar sem maiores problemas. Então o GitHub hospeda projetos públicos, como é muito conhecido, mas também repositórios privados ilimitadamente se você está no gratuito. Isso é muito importante. Descendo um pouquinho, nós podemos ver aqui que nós temos também 2 mil minutos de Actions por mês. Isso caso você esteja utilizando um repositório privado. Caso você esteja utilizando o repositório público, tem uma informaçãozinha menor aqui. Ele é gratuito para repositórios públicos. Essa informação está logo abaixo dos 2 mil minutos de CI/CD por mês. Você pode executar com os Hosted Runners pelo GitHub, você pode isso aqui rodar para seus projetos Open Source ou privados com Actions gratuitas, também é muito legal. Descendo um pouco mais, nós temos a informação de que nós temos 500 MB de armazenamento de pacotes. Isso é o mesmo esquema do GitHub Actions. Esses 500 MB são para repositórios privados. Abaixo dessa informação, temos aqui: "Gratuito para repositórios públicos", então, se você está trabalhando com projetos Open Source, projetos públicos, você não tem custo nenhum para armazenar seus pacotes. Descendo um pouco mais, nós podemos visualizar aqui 120 horas de Codespace, de computação com Codespace baseado no núcleo. Então depende do modelo de máquina de Codespace que você vai utilizar, mas basicamente isso aqui está falando que você pode utilizar o GitHub Codespace, que nós comentamos que é uma IDE na nuvem, de graça, também, por essas 120 horas por núcleo. Então tudo depende do modelo de máquina que você vai. então vai ter mais ou menos tempo baseado nesse cenário. Abaixo, nós também temos a informação de que nós temos 15 GB para armazenamento do Codespace, porque quando você cria um recurso, ele cria basicamente um container, uma máquina rodando na nuvem. Então tem o custo para esse armazenamento também. Então nós temos 15 GB gratuitos para isso. E se nós descemos um pouco mais, podemos ver aqui que o suporte de comunidade está disponível. Vamos subir a tela aqui um pouquinho de novo, e ao lado do Free, nós temos aqui o que ele me recomendou, que é o GitHub ENTERprise, baseado no que... baseado naquela customização que nós falamos anteriormente. E aqui ele está me dizendo que tudo que está no Free e nos outros planos, mais o Single Sign-on, que tem no ENTERprise, auditoria avançada e gestão de usuários avançada, a parte de proteção de ambientes, regras de repositório, logs de auditoria, suporte a SOC, suporte ao GitHub Connection. A partir de Actions gratuitas aqui sobe para 50 mil minutos por mês e a parte de armazenamento de pacotes também sobe para 50 GB. Além de opções exclusivas aqui do ENTERprise, como o GitHub Advanced Security e o Suporte Premium. Aqui você pode escolher, então, qualquer uma das duas, pode clicar em qualquer um dos dois botões. Eu vou clicar no Continue for Free. Provavelmente você também. E vamos lá! E agora aparece a telinha carregando aqui nesse espaço. Está inicializando o seu dashboard e caímos na tela inicial do Git.

 O que é GitHub Actions
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
E agora chegamos à parte que mais nos interessa. Se nosso treinamento é sobre GitHub Actions, então vamos começar a entender o que que é o GitHub Actions, de fato. Bom, o GitHub Actions, ele é uma ferramenta de automação extremamente flexível dentro do GitHub. E por que que eu digo que é uma ferramenta flexível? Bom, com GitHub Actions nós podemos fazer uma infinidade de processos de automação. Incluindo desde o mais clássico, como uma automação de Build, uma automação de testes, uma automatização do processo de Deployment da sua aplicação, até uma automação nos mais diversos cenários. Nós vamos ver aqui no decorrer desse treinamento, uma infinidade de possibilidades de executar as nossas Actions. Mas eu já adianto para você aqui, nós podemos executar Actions baseados em Pull Requests, baseados em Issues, baseados em praticamente qualquer evento dentro do GitHub. Qualquer coisa que você pode clicar em um botão dentro do GitHub, pode disparar uma GitHub Action, que vai te permitir fazer os mais diferentes tipos de automação. Por exemplo, tem uma automação que eu criei que eu vou mostrar para vocês aqui no decorrer desse nosso treinamento, onde eu gero certificados de participação para participantes dos meus eventos gratuitos. Isso tudo utilizando GitHub e GitHub Actions como motor de automação. Outra coisa muito interessante do GitHub Actions é o suporte a múltiplos ambientes. Então nós não precisamos ficar presos a um único cenário, a um único ambiente. Nós não precisamos ficar presos ao ambiente de Cloud, nós também podemos suportar ambientes On-premises, e isso tudo torna o GitHub Actions uma ferramenta extremamente flexível. Então, aqui, nós podemos fazer uma infinidade de coisas usando o GitHub Actions e mantendo o núcleo principal de uma ferramenta de DevOps, como nós vimos, automatização do processo de Build e Deployment, que são os mais clássicos que nós vamos com certeza utilizar no nosso dia a dia de projetos.


Ambientes suportados pelo GitHub Actions
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Antes de começar a falar mais a fundo sobre os ambientes suportados pelo GitHub Actions, existem aqui algumas informações relevantes que você precisa, sim, saber sobre essa questão. Quando a gente fala sobre automação, a gente precisa de algum elemento aqui para executar esse processo. E é aí que entram os Runners do GitHub Actions, tá? Por quê? Porque são esses Runners que executam as automações, e a gente vai entrar mais a fundo em breve aqui, tá? Mas, nesse momento, basta você saber que é com esses Runners que a gente pode fazer basicamente todo o processo de Build e Deployment da nossa aplicação do nosso ciclo de DevOps aqui, tá? Durante um processo de Build e Deployment, a gente acaba passando por um cenário muito importante. Por exemplo, imagina que a minha aplicação, ela só vai rodar em Windows ou só vai rodar em Linux, ou, por algum motivo, eu preciso de um MacOS. Tá? Então, como é que eu vou fazer isso funcionar? Eu preciso me preocupar em criar ambientes muito específicos? Não. Por quê? Porque o GitHub Actions já fornece para a gente Runners que rodam em ambientes Windows, Linux e também MacOS, tá? Então tudo isso já hospedado pelo próprio GitHub. E vale a pena citar que, apesar desses Runners do GitHub Actions suportarem esses três sistemas operacionais, quando a gente está falando de ambiente, não é só disso que eu quero falar, tá? Eu quero falar também de ambientes de Deployment em si, como ambientes de nuvem ou outro ambiente que você vá fazer o Deployment da sua aplicação. E aí, quando a gente olha para nuvem aqui, nós não estamos restritos a usar somente uma plataforma de Cloud, por exemplo, ou somente um cenário específico. Aqui dentro do GitHub Actions, a gente pode preparar o nosso Deployment para ser executado em ambientes Azure, em ambientes AWS, ambientes GCP, ambientes Alibaba Cloud ou em ambientes On-premises, no caso de você querer fazer um Deployment para dentro da sua própria infraestrutura, dentro da sua própria empresa, ou mesmo cenários FTP ou qualquer outro cenário que você possa imaginar, tá? O GitHub Actions, ele possui uma grande flexibilidade, já que pode ser executado em basicamente qualquer sistema operacional e basicamente qualquer destino da sua aplicação também, seja ele nuvem, seja ele On-premises, ou seja, qualquer um outro aqui, tá? Então, recapitulando, qualquer ambiente de nuvem aqui é suportado, qualquer sistema operacional também é suportado, incluindo aqui seus ambientes On-premises nessa questão. Ambientes que usam FTP também são suportados. Imagine que você precisa, por alguma questão, conectar no SSH? Também é um ambiente suportado. Enfim, basicamente tudo que você precisa fazer em relação a ambientes para que o seu Deployment funcione, para que o seu Pipeline funcione, você consegue fazer aqui no GitHub Actions.

Habilitar transcrições interativas


Onde usar o GitHub Actions
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
E onde então nós vamos utilizar o GitHub Actions? A possibilidade de automação com essa ferramenta é extremamente gigante, porque nós temos uma flexibilidade muito grande com o GitHub Actions, já que basicamente qualquer coisa pode ser automatizada. Mas vamos então visualizar algumas opções de Pipeline que nós temos aqui, para que você tenha algumas ideias do que você pode ou não criar aí no seu projeto, na sua aplicação. O primeiro desse processo mais simples de todo, eu diria que é o Pipeline de Build. E o que entra nesse Pipeline de Build? Bom, o processo de compilação é essencial, não pode faltar. Testes unitários também é uma questão muito importante. Análise de qualidade. Poderíamos colocar aqui também, talvez, a geração do artefato, mas isso depende do momento que o seu pipeline está rodando. Nós podemos ter também Pipelines de Segurança, onde nós vamos analisar dependências, analisar secrets, analisar vulnerabilidades. Pipeline de Deployment. Nós temos o quê? Configuração de ambiente, implantação da aplicação, testes de fumaça. E o que mais nós podemos colocar aqui também? Pipeline de Infra as Code, para criar o seu processo de infraestrutura em nuvem ou até mesmo no seu Ambiente On-premises. Outras possibilidades, algumas ideias extras que fazem sentido em um Pipeline de Build, Release e outras automações. Interação com issues, interação com pull requests e também integração com outros eventos do GitHub. Por que eu digo interação com outros eventos? Bom, basicamente, tudo dentro do GitHub pode disparar um Pipeline. Então qualquer coisa clicável num botão você pode criar uma Action que vai executar alguma automação para isso. Então você fica muito livre para fazer uma infinidade de processos diferentes. Basicamente, o que você pensar de automação é provável que você consiga fazer aqui com o GitHub Actions.

Habilitar transcrições interativas


 Criando um primeiro pipeline
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Então, vamos começar aqui a criar o nosso primeiro Pipeline no GitHub Actions. Eu criei esse repositório de teste inicial aqui, onde... Não temos nada nesse repositório, não temos aplicação, não temos nada, a não ser um arquivo de README descrevendo este repositório. Vamos então partir para a parte que nos interessa, que é a criação do nosso Pipeline. Para começar, nós podemos acessar a parte de Actions no menu superior da página, onde nós encontramos Code, Issues, Pull Requests, e aí nós temos a opção de Actions. Vamos clicar no botão Actions e, nessa tela que carregou, nós temos as opções para criar o nosso primeiro Pipeline. Logo no começo, como não temos um Pipeline inicial, é sugerido a criação de um Pipeline inicial chamado Simple Workflow. Para criá-lo é bem simples, basta você clicar no botão Configure, mas vamos dar uma leve olhadinha no restante da tela antes de clicar nesse botão. Aqui nessa tela é sugerido uma série de Pipeline, de templates de Pipelines que você pode utilizar para criar o seu processo. Descendo um pouco aqui a tela, nós temos a área de Deployment, onde nós podemos ver aqui Pipelines de Deploy Node.js para o Azure Web App. Então nós podemos ver aqui que suportam Pipelines para o Azure. Temos também aqui, ao lado do Azure, a opção de Deploy to Amazon ECS. Ok, então também suportamos AWS. Olhando um pouco mais ao lado, temos também Build and Deploy ao GKE, ao Google Cloud Platform. Um pouco mais ao lado, Terraform. Ou seja, nós podemos ver aqui que temos uma infinidade de possibilidades de integração com o GitHub Actions para o Deployment das nossas aplicações. Descendo um pouco mais, podemos ver aqui uma área de Security. Como, por exemplo, o CodeQL Analysis, que é a ferramenta do GitHub de análise de vulnerabilidades. Temos também suporte a DevSkim. Também temos suporte a outras ferramentas, como Anchore Grype, Sysdig e várias outras. Essas são só as que estão sendo sugeridas inicialmente. Descendo um pouco mais na parte de Continuous Integration, podemos ver Deino, Haskell, AWS. Descendo um pouco mais, nós podemos ver automações mais genéricas como Greetings, onde quando um usuário criar uma nova issue pela primeira vez receberá uma mensagem no seu repositório de boas vindas. Também temos aqui Manual workflow, Labeler, Stale. Descendo um pouco mais, temos aqui interação com Pages. Vamos voltar para a parte superior da nossa página. Então agora vamos criar o nosso Workflow inicial. Então nós temos aqui a sugestão que ele trouxe do Simple Workflow, e é ele que nós vamos usar. Então clique no botão Configure, do Simple Workflow, e será carregada uma nova tela onde nós podemos ver o Pipeline de exemplo utilizado.

 Estrutura de um pipeline
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Agora que nós temos aqui criado o nosso primeiro pipeline, vamos dar uma olhada aqui um pouquinho na estrutura dele para entender um pouquinho melhor de como ele funciona. O legal de termos usado este Simple Workflow é que ele já traz aqui vários comentários que nos auxiliam nesse entendimento da estrutura. Tá bom? Então, já está aqui a primeira sugestão que falando que esse é um Workflow básico para você começar a usar o GitHub Actions. O primeiro campo que realmente importa aqui, este é o Name, onde nós podemos configurar o nome do nosso Pipeline, onde nós vamos poder acompanhar isso depois no dashboard de GitHub Actions para podermos ter noção ali do que vai executar, do que executou, do que nós queremos e tudo mais. Outra parte que nós vamos nos aprofundar aqui em breve é que nós temos aqui Triggers onde nós podemos configurar como os Pipelines vão ser aqui iniciados. Nós temos aqui a estrutura de Jobs, onde nós configuramos todos os trabalhos do GitHub Actions, e aqui é um Job, de fato. E aqui dentro eu estou arquitetando um novo Job. E aqui eu tenho o meu primeiro Job chamado de Build. Aqui, onde nós vamos executar, em qual Runner nós vamos executar, nesse caso aqui no Runs-on e aqui nós temos os Steps, que são as coleções de passos aqui dentro. E aqui basicamente são os passos do nosso Pipeline. Então essa é a estrutura básica de um Pipeline, ok? Nós temos o nome, temos as Triggers, temos Jobs e temos aqui também os Steps, ok?


Triggers
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Nessa parte do nosso pipeline, onde encontramos a chave on, é onde configuramos as triggers do GitHub Actions, ou seja, como ele vai ser executado, o que vai disparar este pipeline. Nesse pipeline de exemplo que nós acabamos de criar, algumas triggers já foram incluídas, como por exemplo Push na branch main; Pull request, na branch main, e mais esse outro aqui que é o workflow_dispatch. O que significa isso tudo? Bom, voltando para o primeiro, Push na branch main significa que esse pipeline, ele vai ser executado toda vez que você submeter um novo código, uma nova alteração na sua branch main. Ou seja, você fez um Commit na branch main, vai disparar esse pipeline. Mas você pode estar pensando: "Ah, mas eu quero fazer isso não só para a branch main. Eu quero que esse pipeline seja executado automaticamente quando fizer um Push para minha branch de feature". Sim, isso também é possível. Basta você colocar nas regras de branch também a configuração de nomenclatura certa para sua branch de feature, por exemplo, ou para sua branch develop, ou a branch que for. O segundo ponto que nós temos aqui nessas triggers é a trigger de Pull request que, basicamente, significa que toda vez que eu criar um Pull request apontando para branch main, esse pipeline vai ser executado. Ou seja, estou eu trabalhando na minha branch de feature, preciso fazer o merge para a branch main. Como eu faço isso? Eu vou criar um novo Pull request, certo? Então eu estou apontando um Pull request da branch feature para a branch main. Então, esse pipeline vai ser executado. Se eu estiver fazendo um Pull request da minha branch de feature para branch de develop, esse pipeline não será executado porque ele não respeita essa regra, certo? Do jeito que está aqui em cima, com esses dois blocos Push e Pull request, esse pipeline será executado apenas nesses dois casos. Se eu tiver um Push"ou se eu tiver um Pull request. Uma trigger essencial, eu diria, pelo menos para mim é muito útil, é a possibilidade de você executar isso manualmente usando a workflow_dispatch. Workflow_dispatch permite que você execute isso quando você quiser, porque ele vai trazer um botão no seu pipeline, onde você pode clicar e iniciar a sua execução. São só limitadas a essas triggers? Não. Nós podemos ter uma infinidade de outras triggers aqui, que nós vamos ver no decorrer desse curso.

Habilitar transcrições interativas

 Jobs
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Descendo um pouco mais, entramos na área dos jobs. O que que seriam os jobs? Seriam os trabalhos que esse pipeline vai realizar. E aí, dentro do nosso pipeline, nós precisamos organizar isso. Então, para começar, nós precisamos colocar a chave "jobs", porque com isso nós identificamos que o que vem abaixo aqui agora, no primeiro nível de indentação, será um job propriamente dito. E nesse caso, o nosso primeiro job é chamado de "build". Seguindo a indentação, nós temos jobs. E aí, dentro desse job nós temos um job, que, no nosso caso, é chamado de build. Dentro dele virão de fato as tarefas que serão executadas. Então nós temos um bloco maior de jobs e dentro deste bloco de jobs nós temos cada job individualmente. Que, nesse caso, nós podemos configurar algumas coisas, como, por exemplo, qual vai ser o runner que vai executar esse nosso pipeline e também, posteriormente, os passos.


 Steps
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Dentro aqui do nosso job, agora nós precisamos ter o quê? Precisamos ter as tarefas que vão executar de fato a nossa Action. Então para isso nós temos aqui um bloco de steps que, basicamente, representa a sequência de passos que vai ser executada dentro desse nosso job propriamente dito. Então, nesse nosso pipeline de exemplo, alguns passos aqui vieram incluídos, como esta Action de checkout, que basicamente ela faz o quê? Ela vai baixar o código-fonte do seu repositório para ser utilizado dentro dessa automação específica. E logo abaixo nós temos outros dois passos, que um deles é um run de Single line, ou seja, estou executando um comando de linha de comando simples, que é tudo numa linha só, e no de baixo nós temos a mesma coisa, só que em Multi-line, para eu poder executar scripts mais complexos. Isso aqui são alguns steps que nós precisamos utilizar no nosso pipeline, mas não precisamos nos limitar a isso, porque nós temos outras possibilidades de inclusão de steps além dos scripts, que é buscando essas tasks no Marketplace.


 Buscando tasks no marketplace
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Aqui ao lado do nosso pipeline, na tela de criação, nós já temos a possibilidade de buscar algumas tasks no Marketplace. Inclusive, já tem aqui umas sugestões baseadas em padrões de uso. Quais são as tasks mais usadas nos pipelines comumente, como, por exemplo, um Setup Node.js, um Setup do Java JDK, Setup do.NET Core e várias outras. Então, se você quiser utilizar algumas dessas Actions, como funciona baseado nessa tela aqui? Você pode vir, por exemplo, no Setup.NET Core, clica nele e essa telinha vai abrir para você com uma pequena documentação. E aqui vai ter um passo a passo de como você pode incluir isso no seu pipeline. Basta basicamente você copiar este código, dar um ENTER aqui e colar. Agora que nós colamos, precisamos apenas ajustar a indentação, já que a indentação ali está bagunçada, de onde nós copiamos. E a identação é algo muito importante no YAML. E aí, agora, basicamente seria só utilizar essa nossa task do Marketplace. Mas para buscar a task no Marketplace não precisamos ficar limitados apenas a esse uso aqui. Se você acessar esse outro endpoint do github.com/marketplace, você pode encontrar vários outros aplicativos e inclusive Actions. Então, na tela de busca no menu lateral, basta você filtrar por Actions e você encontrará uma infinidade de Actions disponíveis aqui. Você pode vir e buscar pelo tipo que você precisar. Então se eu quero buscar por Azure, por exemplo, basta eu digitar "Azure" na caixa de busca e poderemos encontrar uma infinidade de Actions disponíveis. Uma informação importante! Quando você olha cada uma dessas Actions, é possível que você veja que tem um check em algumas delas escrito "Creator verified by GitHub", ou seja, criador verificado pelo GitHub. Isso é importante porque significa que essas Actions são de confiança, são validadas pelo GitHub. Porque é uma questão aqui muito comum que qualquer pessoa pode publicar uma Action no Marketplace. Então, pode acontecer de alguma Action ser indevida ou de não agir exatamente como você espera. Vamos buscar Actions aqui, por exemplo, "Terraform". Nós podemos encontrar algumas Actions que não tem essa verificação do GitHub, ou seja, o GitHub não verificou. Isso significa que essa pessoa, esse time, essa organização não passou pelo processo de validação. Significa que você não deve usar? Não, não tem esse significado, mas significa que você deve ter algum nível de atenção. Outra coisa bastante interessante sobre as Actions no Marketplace é que quando você clica em alguma delas, por exemplo, você pode ver aqui essa documentação, ensinando o uso geralmente tem também. E aqui no menu ao lado, próximo ao botão de uso do latest version, podemos ver stars, quem contribui, mas também tem uma seção de links. E quando você clica nesse link, basicamente você vai para o repositório dessa Action. Então você consegue acompanhar o código fonte e visualizar tudo que foi feito, entender. Você pode, inclusive, submeter alterações e Pull requests para atualizar essa Action.


 Executando o pipeline
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Agora vamos então executar este nosso pipeline? Para isso eu vou remover este bloco de.NET Core que nós colocamos aqui. Ele não é necessário para esse nosso exemplo. E agora vamos subir um pouco a tela e eu vou clicar no botão de Commit changes, para de fato salvar este pipeline dentro do meu repositório. Vai abrir a tela de Commit, onde eu posso customizar a mensagem de Commit. Eu vou fazer essa alteração direto na branch main. E agora eu vou clicar aqui no menu de Actions. E esse pipeline já está sendo executado, ou melhor, já foi executado, porque é um pipeline bastante rápido. Porque lembram da trigger do Push na branch main? Então, foi ela que foi atendida. E agora, se eu clicar na execução deste workflow, onde nós podemos ver aqui nessa lista, nós vamos carregar uma nova tela onde podemos visualizar os detalhes deste nosso pipeline. Na parte superior dessa tela que carregou, nós temos um botão onde nós podemos executar todos os jobs. Descendo um pouquinho essa tela, nós temos uma pequena visualização onde nós conseguimos saber quem foi que iniciou este pipeline. No caso, foi o meu usuário quando fez um Push com este ID específico para a branch main. Dá para nós sabermos também o status, se foi sucesso ou falha. Podemos saber inclusive o tempo de duração, que nesse nosso caso foi de 12 segundos, e também se gerou ou não artefatos. Nesse caso, não gerou nenhum. Descendo um pouco a mais, nós podemos visualizar aqui a tela de estrutura deste nosso pipeline. Como nós só temos um único job chamado Build, ele é o único que aparece aqui. Se tivéssemos outros jobs, eles apareceriam aqui também, de forma que nós pudéssemos visualizar isso de forma gráfica. Indo para o menu lateral, nós temos a opção de acessar diretamente o job. Então eu vou clicar aqui em Build. E aí quando, nós clicamos em build, é carregada essa nossa nova tela, onde nós podemos visualizar todos os logs de execução. Então nós podemos expandir cada uma das opções exibidas na tela, como o set up job, e saber o que aconteceu aqui. Como, por exemplo, nós sabermos qual que é a versão atual do runner, qual é o sistema operacional, qual é a imagem que está sendo executada. Várias informações bastante relevantes para um processo de debug do pipeline. Nós podemos ver o que aconteceu quando foi executado a task de check out, por exemplo, foi toda a parte de download do código fonte. E aqui as tasks de one-line script, onde foi escrito "Hello, World" e na multi-line script também, onde foi escrito a outra mensagem que estava lá. Depois nós temos dois outros jobs extras, que são jobs automáticos do próprio GitHub Actions. Nós não interagimos com eles, que basicamente é para limpar o ambiente e deixar o Action disponível no processo.




Pipelines multi-stage
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Então nós vamos falar agora um pouquinho sobre Pipelines Multi-stage. O que que são esses tipos de pipeline? Basicamente são aqueles que possuem dois ou mais jobs ali para a execução. Nos vídeos anteriores nós vimos aqui que os pipelines possuem ali uma estrutura básica com nome, com trigger e tem ali o bloco de Jobs, onde nós tínhamos o job de build. Deixa eu até compartilhar minha tela com vocês aqui. Onde nós temos este único job de build, onde ele executa aqui dentro do runner de Ubuntu, tem esses steps aqui, mas se você tiver trabalhando no ambiente de build, deploy de uma aplicação, muito provavelmente você vai precisar ter mais do que apenas um job, do que o caso de apenas o job de build. Provavelmente você vai precisar de um job para deploy de dev, homologação, produção e assim vai de acordo com o ambiente da sua aplicação. E é aí que entram esses nossos multi-stage pipelines que nós estamos falando. E para sua criação, ele também é um processo bem simples, tá? Para isso basta eu entrar no fluxo de Jobs, onde nós já temos o build e criar mais um nó na mesma estrutura de indentação. Já que nós estamos trabalhando aqui com arquivos YAML, a identação é muito importante. Então aqui eu estou na mesma linha de build e eu vou criar aqui um chamado "deploy-dev:", ok. E aí, abaixo desse deploy-dev, que está na estrutura de build, eu preciso que tenham os passos para que isso reconheça e funcione. Para esse nosso exemplo, eu vou usar exatamente os mesmos passos. Então eu vou copiar e colar aqui no deploy-dev. Então nós temos aqui configurados dois jobs: build e deploy-dev. Vou fazer o Commit disso aqui, alterar e vamos executar este nosso pipeline para vermos como isso ficou. Então vou aqui "Run Workflow". Vou clicar aqui "CI" e, olha, nós já podemos ver aqui que o que aconteceu? Nós temos sim os dois jobs aqui, mas eles estão sendo executados em paralelo. Por quê? Porque nós não configuramos nenhum tipo de dependência entre eles, então eles vão executar os dois simultaneamente. Isso pode fazer sentido no seu cenário? Pode, porque cada caso é um caso. Então é bom a gente saber que existe essa possibilidade. Mas para bater no cenário que nós estávamos falando antes de build, deploy, em desenvolvimento, em produção e em homologação, o fluxo normal é que nós tenhamos primeiro build, depois apenas aconteça o deploy de dev e depois os outros deployments. Então, como é que nós fazemos isso dentro do nosso pipeline? Vou voltar aqui no modo de edição do arquivo e aqui nós precisamos colocar uma nova chave. Seria a chave "needs", onde eu digo qual é o job que ele precisa esperar, então ele precisa esperar o build. E aqui... Opa! Está escrito errado o build. Eu preciso colocar exatamente como está lá em cima para que ele reconheça esse processo. Então o que vai acontecer aqui? Vai ser executado primeiro o build, depois vai ser executado o deploy-dev aqui. Eu vou fazer o Commit dessas alterações. E vamos lá executar este pipeline para ver aqui como vai funcionar agora. Então agora aqui o nosso pipeline multi-stage não acontece tudo de uma vez só. Ele está rodando o primeiro o build e, quando o build for concluído com sucesso, aí sim vai iniciar o processo de deploy-dev, como vocês poderão ver aqui. Então a gente consegue construir estes workflows aqui dentro com o multi-stage pipeline. Então, se você estivesse um deploy homologação, deploy produção, bastaria você criar um outro bloco aqui na estrutura dos jobs para que seja um multi-stage em pipeline.

Habilitar transcrições interativas



 Environments: o que são e como configurá-los
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
E aqui agora a gente vai falar um pouquinho sobre os Environments. O que que são esses Environments? Lembra que nos vídeos anteriores nós falamos aqui da criação de um pipeline multi-stage, onde nós tínhamos o processo de build e o processo de deployment, Deployment em dev? E nós comentamos a questão de ambiente, de desenvolvimento, de homologação e produção? Basicamente, os Environments são esses ambientes de Deployment no GitHub actions para que nós tenhamos ali uma configuração mais segregada por ambiente. E por que eu digo isso de termos uma configuração segregada? Imagina que você tem um ambiente de desenvolvimento e homologação e produção da sua empresa e em todos eles você vai fazer, por exemplo, o deployment no ambiente do Azure diferente, e cada um tem algumas credenciais ou variáveis diferentes, ou um processo de aprovação, de implantação diferente. Como é que você gerencia isso dentro do GitHub Actions? É usando justamente essa questão dos Environments. Então vamos voltar aqui para o nosso código. Eu estou aqui com aquele pipeline que nós acabamos de criar aqui, onde eu tenho o job de build e o job de deploy-dev, que precisa que o processo de build funcione. Esse workflow funciona? Sim, funciona. Nós vimos que ele funciona, ele estrutura isso em build e deploy, processos que funcionam separados, mas nós não conseguimos aqui, por exemplo, em ter um processo de aprovação configurável para esse ambiente de dev. Nós não conseguimos ter variáveis e segredos para esse ambiente, exclusivamente. Nós vamos ver nos vídeos mais a frente como funciona esse processo de segredos e variáveis e como nós podemos utilizar ele de várias formas. Então nós poderíamos sim, teoricamente, usar isso sem ser num ambiente, mas no ambiente nós conseguimos separar um pouco melhor as coisas. Então como é que eu crio esse ambiente para poder usar aqui? Primeiro eu vou vir aqui na parte de configurações do meu repositório e aí, nessa barra lateral, eu vou procurar por "Environments", que está aqui. E aqui ele me diz que esse repositório não tem nenhum Environment configurado, ok? Então vou vir aqui em "New Environment". E aqui eu vou dar o nome de "desenvolvimento". Vou configurar esse Environment e aqui nós temos algumas regras que nós podemos configurar aqui dentro para esse processo. A primeira delas é ter revisores obrigatórios aqui. E aí você pode ter aqui até seis revisores. Você pode configurar grupos e times da sua organização. Isso é importante para quê? Para que um processo de implantação, por exemplo, em produção, não entre de forma automática e sem ninguém saber, porque em vários dos casos, na maioria deles, nós não temos ambientes maduros o suficiente para esses deployment acontecerem de forma transparente nos ambientes. Em vários casos até temos, tá? Já passei por vários clientes onde nós temos deployments que acontecem automaticamente em todos os ambientes, mas na grande maioria dos casos, nós precisamos de algum processo de aprovação. E é aqui que você configura quem vai aprovar, tá? Aqui eu estou configurando eu mesmo, porque, bom, só tem eu mesmo nessa minha conta e é só para o nosso teste. Mas o ideal é que seja uma pessoa diferente, tanto que temos essa segunda configuração aqui, que é para prevenir a auto-revisão, que é o que eu vou fazer no caso, mas em um ambiente produtivo não deveria, porque isso me permitiria criar alterações e colocar alterações nos ambientes meio que sem ninguém saber. E isso não seria o mundo ideal na grande maioria dos casos. Então você marca aqui o Prevent self-review, que eu vou deixar desmarcado por motivos óbvios, senão eu não vou conseguir executar aqui com vocês. Mas no mundo de vocês muito provavelmente isso aqui vai estar marcado. Outra coisa que nós temos aqui é um tempo de aguardo. Para que que serve isso? Para que você... O seu processo de deployment aqui no ambiente, ele aguarde alguns instantes antes de iniciar. Então eu aprovei aqui o deploy em produção, mas eu não quero que ele execute imediatamente. Eu quero que ele execute só daqui a 15 minutos, daqui a 20 minutos após a minha aprovação, porque eu tenho uma janela ali no meu ambiente. Enfim, é aqui que você configura isso. Você configura quanto tempo isso deve ser aguardado antes de ser executado no ambiente. Outra coisa bem importante que nós temos aqui é: administradores podem bypassar esta regra, ou seja, administradores podem ignorar essa regra aqui de cima. Eu vou salvar ela aqui já para gente não esquecer. Salvamos. Então agora que eu tenho meu usuário como aprovador. Deixa eu desmarcar o wait timer aqui, que eu não quero que ele aguarde também não. Isso aqui está desabilitado, ok? Outra coisa que nós temos aqui é o deployment de branches e tags, tá? Para quê que serve isso? Isso aqui serve para poder restringir quais branches vão executar nesse ambiente. Então, imagina, o que eu quero é que o deployment para desenvolvimento ocorra apenas se tiver sido feito um Commit, um merge, um co-request para branch de develop ou desenvolvimento. É aqui que eu configuro isso. Desse jeito que tá, eu posso executar isso a partir de qualquer branch, mas para nossa demonstração isso funciona muito bem. Ok? Então volto aqui para o meu script. Como é que eu configuro agora para usar este ambiente que nós acabamos de criar? Para isso eu vou vir aqui e vou criar uma nova chave chamada environment. E aqui eu vou criar uma chave "name", onde eu vou dizer qual é o nome desse nosso ambiente que a gente acabou de criar. "Desenvolvimento". Está escrito certo? Está escrito certo. E aí eu vou fazer o Commit dessas alterações. E vamos dar lá uma olhada nas actions. Como é que essa execução vai funcionar agora? Então eu vou vir aqui, executar o meu workflow. Vamos abrir aqui a tela do workflow e, assim como nós já vimos antes, o processo de build vai ser executado, logo em seguida vai cair o processo de deployment de dev, onde provavelmente vai pedir a minha revisão. E é exatamente isso que aconteceu. O processo aqui, ó, ele está pausado porque ele precisa que eu faça a revisão disso em desenvolvimento e aqui embaixo nós, inclusive, conseguimos ver aqui, ó, que tem a Protection Rule, que o meu usuário foi requisitado como revisor no ambiente de desenvolvimento. Então eu posso vir aqui, revisar esta alteração, marca a caixinha de desenvolvimento e deixo um comentário aqui. "Aprovado para deploy". E aí eu faço isso, aprovo e faço o deploy. E aí, agora sim, esse processo vai ser executado, como nós já estávamos esperando, fazendo essa implantação dentro do ambiente de desenvolvimento. Beleza?

 Secrets: o que são e como configurá-los em repositórios, ambientes e organizações - Parte 1
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
O que são as Secrets? Em um pipeline é muito comum nós precisarmos utilizar keys, chaves de acessos, credenciais, dados sensíveis para que o nosso processo de build, deployment, de automação em um geral, aconteça com sucesso. Só que como esses dados são sensíveis, nós não podemos deixá-los expostos de qualquer maneira. Então para isso existem as Secrets dentro do GitHub Actions. Dessa forma, nós podemos armazenar todos esses valores de uma forma segura e criptografada, com a qual nós não vamos conseguir ler ele de forma simples. Se eu tentar direto pelo próprio GitHub, por exemplo, eu não consigo ler. Se eu tentar pelo pipeline, ele criptografa esse valor, ou seja, mantém ele de forma segura. Vamos dar uma olhadinha nisso na prática agora então. Estamos aqui com o nosso pipeline de exemplo, que nós já criamos o nosso pipeline simples aqui, e gostaríamos de utilizar uma Secret. Como isso funciona? Para começar, nós podemos ir no menu superior e clicar no botãozinho "Settings". Clicando em Settings, nós vamos poder visualizar algumas informações desse nosso repositório como General, mas ao lado esquerdo nós temos uma opção bem interessante, que é um menu lateral. Nesse menu lateral nós podemos ver uma série de coisas, mas nós vamos descer até a parte onde diz "Secrets and Variables". E dentro de Secrets and Variables nós iremos clicar no menu Actions. Dentro dessa área que nós clicamos, de Actions, nós podemos visualizar aqui as questões de Secrets e também de Variables. Variables nós vamos visualizar mais para frente no nosso curso, então aqui nós podemos visualizar os três níveis de Secret, o primeiro deles sendo Environment Secrets, o segundo Repository Secrets e o terceiro Organization Secrets. Todos funcionam mais ou menos da mesma forma, mas em níveis diferentes. Vamos começar aqui pela parte de Repository Secrets. Nós vamos criar aqui uma nova Repository Secrets clicando no botãozinho "New Repository Secret", ou seja, novo segredo do repositório, e será carregado uma nova tela, onde nós podemos definir o nome dessa nova Secret. "Secret..." Eu vou colocar o nome de "SECRET_REPO". E o valor nós podemos colocar qualquer um. Aqui nesse caso, já que é só um exemplo, eu vou colocar aqui "SEGREDO". Vou adicionar esta Secret. E agora nós temos aqui, em Repository Secret, uma nova Secret. Um ponto importante, como eu estava dizendo anteriormente, é que essa Secret, ela está segura aqui dentro do GitHub. Quando nós estamos em uma Secret, nós podemos visualizar aqui, à direita de cada uma delas, um botão Edit e um botão de excluir. Se eu tentar editar esta Secret, vejam que eu não posso visualizar o valor dessa Secret, porque o campo vem vazio, ou seja, eu não consigo ler essa Secret. O GitHub está mantendo isso seguro para evitar vazamentos de dados. Imagina que alguém conseguiu a sua credencial do GitHub. Essa pessoa não vai conseguir ver as Secrets que existem no projeto, mantendo seus valores seguros. Ok? Então vamos utilizar essa Secret para que você entenda como ela funciona. Eu vou copiar o nome dela aqui e vou abrir o nosso pipeline de exemplo. Vamos editar ele aqui. E para utilizar essa Secret é bem simples, eu vou selecionar um passo de execução que nós temos, que é o run, porque ele executa linhas de comando, então vai ser simples escrever o valor dessa Secret na tela. Então estou usando aqui o one-line script. É o segundo step desse nosso pipeline no job de build, e tá aqui hoje escrito "echo Hello, world". E eu irei adicionar o valor dessa Secret. Para isso, coloca o cifrão, abro chave duas vezes e coloco o texto "secrets.SECRET_REPO", e fecho, fecho chave. Vou fazer a alteração aqui, efetivar isso com o Commit. E agora vamos executar este nosso pipeline acessando o menu Actions, indo na lista de pipeline, clicando nele. E agora indo para o Run Workflow na Branch main. Nosso pipeline está sendo executado. Vou clicar aqui no build para visualizar os logs. Ele está carregando, atribuindo os trabalhos. E agora nós podemos visualizar aqui em Run one-line script, no passo específico que nós configuramos, "Hello World! ***". Por que que está aparecendo esse "asterisco, asterisco, asterisco"? Pelo fato de que esta Secret, ela é criptografada e seria muito simples se pudesse ser apenas exibido no log. Isso quebraria totalmente a segurança, certo? Então, para manter a segurança, o GitHub também criptografa esses valores no log, garantindo assim que o nosso processo esteja seguro. E aí essa foi a nossa Secret por repositório, mas vale uma explicação aqui, extra. Essa Secret por repositório, ela fica disponível para qualquer job dentro do nosso pipeline. Então se eu estiver em qualquer ponto do meu pipeline eu posso utilizar essa Secret de uma forma simples e prática, como nós vimos aqui, porque ela fica disponível para todo o workflow, o que não acontece na de Environment.


Secrets: o que são e como configurá-los em repositórios, ambientes e organizações (Parte 2)
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Outra opção de secret que nós temos, como nós vimos, é a secret por environment. E qual que é a diferença da secret por environment? Deixa eu ir aqui na opção de secrets. Quando nós temos aqui environment dentro do nosso GitHub Actions, a ideia é que tenhamos um isolamento de ambientes. Então a secrets para este environment tem que ser exclusivas para ele, porque imagina que você está tendo um deployment no ambiente de desenvolvimento e produção. Nós podemos ter as mesmas variáveis, só que com valores diferentes. Para isso serve esse isolamento de ambientes. Então, se eu vier para criar uma secret de ambiente, ela vai ter esse nível de isolamento. Vamos então clicar aqui em "Manage environment secrets". Quando eu faço isso, vai abrir aqui a minha tela de ambientes, de environment, onde eu tenho o ambiente aqui de desenvolvimento. Clicando nele, vai carregar a nova tela de ambientes e descendo um pouco a tela, eu tenho uma área de environment secrets onde eu posso clicar em Adicionar, eu vou colocar o nome aqui de "SECRET_DEV", com o nome de "DEV" mesmo, que vai ficar criptografado, vou já copiar este nome, adicionar esta secret, e vamos voltar agora ao nosso pipeline. Estão vendo que aqui, nesse primeiro passo de build, eu coloquei a secret de SECRET_REPO, que nós usamos anteriormente. Vamos mudar aqui agora e colocar a nossa SECRET_DEV, e eu vou copiar também aqui essa SECRET_DEV e vamos descer até o ambiente de desenvolvimento, e eu também vou replicar esta secret aqui em desenvolvimento na mesma task, na run one-line script. Então temos agora esta secret sendo chamada dentro do processo de build e dentro do processo de desenvolvimento. A ideia é que funcione apenas dentro de deploy dev. Eu vou fazer aqui o commit dessa alteração. Commit realizado, vamos executar agora este pipeline da mesma forma que já estamos acostumados. Vou clicar em CI > run workflow, e agora vou abrir aqui para podermos visualizar os logs. Lembrando, temos o processo de build e o processo de deploy. Vou clicar no build para vermos os logs. Vamos ver de one-line script, e agora temos apenas o Hello, World!, sem os asteriscos, ou seja, a nossa secret não foi reconhecida aqui, nada foi feito. Vamos agora para o log do deploy dev, no menu de jobs lateral. Vamos agora para a mesma task no log, run one-line script. E aqui, ao contrário de build, nós temos Hello, World!, asterisco, asterisco, asterisco. Ou seja, foi reconhecido aqui. E ainda há mais uma terceira opção que nós temos de secret. Nós temos o nível de repositório e temos o nível de ambientes, de environment. Então, para podermos configurar essas secrets por organização, podemos visualizar como isso funciona, vamos até a raiz da nossa organização. Na parte superior da nossa tela nós temos a parte onde está demolinkedin/primeiro_pipeline. Demolinkedin é a nossa organização. Basta clicarmos nesse botão então. Clicando aqui, vai aparecer o menu overview, repositórios, projetos. Vamos em settings. Acessando aqui teremos nosso menu lateral, como estamos acostumados com repositórios, e vamos descer até a parte de secrets and variables. Vamos clicar em actions dentro dessa área. E será carregado uma tela para secrets and variables e nós vamos criar uma nova secret de organização aqui. E aqui é a mesma coisa. Eu vou criar uma secret como nome de "ORGANIZACAO", sem acentos e sem caracteres especiais, e no valor vou colocar ele mesmo. Descendo um pouquinho aqui, nós podemos ver uma pequena diferença. Nós podemos ver acesso a repositório. Está marcado por padrão public repositories, ou seja, todos os repositórios públicos desta organização poderão acessar essa secret. Se você expandir esta caixinha, e eu vou descer um pouco a tela aqui nós podemos ver duas outras opções. Private repositories, mas para isso estar habilitado, a minha organização precisaria estar sendo uma organização pagante, que não é o caso. Mas se você paga pela sua organização, vai aparecer o private, ou nós podemos também fazer aqui a parte de selected repositores, que apenas repositórios selecionados terão acesso a esta secret. Então eu vou colocar aqui "selected", aparece essa opção logo ao lado para você selecionar o repositório com uma engrenagem. Vou clicar na engrenagem e vou selecionar o nome do meu repositório, que no caso é o primeiro_pipeline. Vou atualizar esta seleção, adicionar esta secret. E vamos voltar agora para o repositório. Indo na parte de configurações desse nosso repositório e indo em secrets and variables de novo, nós podemos ver agora secrets de ambiente, secrets de repositório e também secrets de organização. Secrets de organização funcionam de forma similar a de repositório, ficam disponíveis para o repositório inteiro, não apenas para um ambiente. Então, se eu vier e consumir essa secret, colocar ela no meu código, vamos editar o código como já estamos acostumados. E no nosso primeiro passo, onde nós colocamos o echo Hello, World!, vou trocar para secrets.ORGANIZACAO, vou fazer o commit dessas alterações e vamos outra vez para o menu de actions para executar esta action e ver como isso funciona. Clicando aqui agora em run workflow para executar. Vamos abrir os logs, visualizar os logs de build ver a task run on-line script e temos aqui Hello, World! asterisco. Ou seja, estamos consumindo a secret de organização também.

Habilitar transcrições interativas


Variáveis: O que são e como configurá-las em repositórios e ambientes - Parte 1
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Variáveis, assim como os secrets, é muito comum que a gente precise armazenar valores dentro do nosso pipeline para reutilizar, como, por exemplo, caminhos de arquivo, diretórios, nomes de aplicações, várias dessas coisas que não são tão sensíveis assim. E esses valores precisam ser armazenados de uma forma na qual nós possamos visualizá-los e editá-los caso necessário, porque, por exemplo, caminhos de arquivos podem mudar dentro de um servidor, então eu preciso saber disso previamente. E aí que entram as variáveis, porque diferente das secrets, esses valores, eles não são criptografados e nós podemos visualizá-los dentro do GitHub para podermos editá-los ou simplesmente saber qual é o valor daquela variável sem precisar fazer um deploy de uma aplicação primeiro. Então vamos voltar aqui ao nosso pipeline inicial que nós criamos. Aqui nós temos hoje uma secret que nós utilizamos nos exemplos anteriores, mas e se eu quisesse utilizar uma variável? Como isso funcionaria? Bom, vamos partir para o mesmo modelo que nós fizemos para o processo de secret, vamos subir aqui a tela um pouquinho, vamos ao menu de settings, na barra lateral, como nós já vimos anteriormente, vamos descer até secrets and variables, clicar em actions, e agora nós temos a tela onde nós podemos visualizar as secrets que já existem no nosso repositório que nós criamos em outro momento. E, ao lado de secrets, no menu de navegação, nós podemos ver que nós temos a opção de variables. Vamos clicar nele aqui. E nós temos opções similares ao processo de secret. Então nós temos environment variables, repository variables e organization variables. Vamos aqui então criar uma nova variável de repositório. É só clicar neste botão aqui que está escrito new repository variable, que seria a nova variável de repositório. Clicando aqui, abre uma tela bem parecida com o processo de secret, onde precisamos definir o nome. Vou colocar aqui variável demo e aqui inclusive tem uma mensagem logo abaixo do nome que diz quais são os padrões desta variável, do nome dessa variável. Então são aceitos apenas caracteres alfanuméricos ou underscores. Espaços não são permitidos, a variável, ela não pode começar com um número e ela também não pode começar com GITHUB_, porque esse é um valor pré definido da plataforma. Sempre que você vai utilizar uma variável padrão do GitHub, ela segue com GitHub underline. Por isso você não pode replicar isso. E o valor? Vamos colocar um valor aqui de demonstração e adicionar esta variável. Quando nós adicionamos, vamos descer a tela um pouquinho, nós podemos ver que temos aqui o nome da variável, já vou copiá-la e ao lado nós podemos visualizar o valor que nós armazenamos. Inclusive, se eu clicar no botão de edição aqui ao lado, nós conseguimos visualizar este valor e até modificá-lo, como, por exemplo, vou colocar um número 2 logo em seguida. Aqui, para atualização, ele só me pede uma confirmação de segurança. Eu vou autenticar utilizando o meu aplicativo mobile. Autentiquei e o valor agora está salvo como demonstracao2. Vamos aqui então utilizar este valor. Retornemos aqui ao nosso pipeline, vamos lá em cima, na tela, clicar em code, achar o nosso arquivo e abrir o modo de edição, como vocês já estão bem acostumados. Clicando aqui na tela de edição, vamos descer até a task de run one-line script que nós estávamos utilizando anteriormente. Aqui nós temos a secret, mas agora vamos passar a utilizar a variável que nós criamos. Então aqui, ao contrário de secrets, vamos utilizar o texto "vars.", e aí o nome da nossa variável, VARIAVEL_DEMO, nesse nosso caso. Vamos realizar o commit dessas alterações. Vamos voltar para o menu de actions, vamos ao pipeline de CI e executar este workflow. Vamos clicar nele aqui na execução vamos olhar o log de build, e agora está sendo executado o processo de check out, vamos olhar aqui o run one-line script e "Hello, World! demonstracao2". Então é assim que nós utilizamos uma variável de repositório. Lembrando que variável de repositório fica disponível em todo o pipeline, não apenas em um job específico.

Habilitar transcrições interativas



 Variáveis: O que são e como configurá-las em repositórios e ambientes - Parte 2
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Ainda sobre processo de variáveis, vamos agora visualizar como é que funciona o processo para variáveis de ambiente. Vamos aqui na outra aba. Eu já estou na área de secrets and variables e vamos clicar aqui em variables. O conceito aqui é bem idêntico ao processo de secrets. Quando nós estamos trabalhando com o ambiente, é comum termos variáveis que precisam ser com a mesma nomenclatura, mas valores diferentes de acordo com o ambiente. Para isso, nós temos as environment variables, que se executam no escopo de ambiente. Então vamos clicar aqui no botão manage environment variables ou gerencie as variáveis de ambiente. Vai aparecer a listagem de ambientes que existem, vou clicar aqui no nosso ambiente de desenvolvimento. Vamos descer a tela aqui um pouco até a área onde nós temos environment variables, que fica logo no final da página e vamos clicar no botão add variables. Vai ser igualzinho o processo de secret e o processo de adicionar variável em repositório. Você adiciona o nome e adiciona um valor. Eu vou adicionar que "VARIAVEL_DEV", e vou escrever aqui "AMBIENTE DE DESENVOLVIMENTO". Vou copiar o nome aqui para ficar mais fácil para usarmos no pipeline. Vou adicionar a variável. Vamos descer aqui um pouco a tela. Agora temos aqui a VARIAVEL_DEV e a SECRET_DEV. Voltando aqui no menu lateral, em actions, na parte de secrets and variables, nós podemos visualizar aquela tela, uma listagem onde vai vir carregado inicialmente como secrets, mas basta clicar no menu navegação para variables. E aqui agora conseguimos ver a variável de ambiente, VARIAVEL_DEV. Nós conseguimos visualizar o valor e também identificar qual ambiente essa variável está atrelada, ok? Vamos voltar aqui então na outra aba para o nosso pipeline. Eu vou pegar esse job de build onde nós colocamos a VARIAVEL_DEMO e vou alterar para VARIAVEL_DEV, e vou também copiar este valor para o processo de deploy-dev aqui em baixo, e substituir a secret que estava anteriormente por esta variável. Vamos então realizar o commit dessas alterações e executar este pipeline e vamos ver como é que vai ser a reação desta nossa VARIAVEL_DEV. Vou subir a tela, vou clicar no menu actions. Vou aqui em actions, no workflow CI, e vamos executar esse pipeline manualmente. E agora vamos aqui clicar no pipeline, nessa execução específica, e acessar o log do processo de build. Dentro aqui nós temos o passo do run one-line scrip. Vejam que agora o log só está escrito "Hello, world!" sem nada extra, porque ele não incluiu a variável, ele não identificou essa variável porque ela está no escopo do ambiente dev e vamos olhar o log aqui ao lado do deploy-dev. Quando vamos ao log, também temos aqui o run one-line script. E aqui, ao contrário do ambiente de build, nós temos o "Hello, World!" ambiente de desenvolvimento, ou seja, conseguimos utilizar esta variável no escopo de ambiente. E ainda falando sobre as variáveis, lembrem-se que nós temos um terceiro tipo de variável, certo? Que seriam as variáveis de organização. Então vamos voltar aqui na outra aba, para a tela onde nós conseguimos visualizar todas as variáveis deste nosso repositório. Eu vou descer aqui até a área de organization variables. E aqui nós temos a mensagem de que esta organização não tem variáveis disponíveis para este repositório e eu posso gerenciar as variáveis dessa organização clicando neste botão aqui. Vamos clicar nele. E automaticamente nós fomos transportados para a tela de configuração de variáveis dentro da nossa organização. Vamos descer a tela aqui um pouquinho e clicar neste botãozinho aqui que se chama create new organization variable, ou crie uma nova variável da organização. Vou clicar, abre aquela tela que nós já vimos anteriormente e vou incluir aqui o nome "VARIAVEL_ORGANIZACAO". Vou copiar já o nome e vou colocar aqui. "ORGANIZACAO CURSO LINKEDIN". E descendo aqui abaixo nós podemos ver o acesso aos repositórios, que ele está disponível para todos os repositórios públicos que existirem dentro da minha organização. Eu posso ter aqui apenas para os repositórios privados dentro da minha organização. Lembrando que isso está desabilitado devido à camada de precificação que eu contratei para esta organização. Eu estou usando a camada gratuita. Se você estiver utilizando a camada private, onde você paga por isso, você vai ter essa opção disponível. Outra opção que nós temos é repositórios selecionados. Vou clicar aqui, aparece uma listinha ao lado, eu vou clicar na engrenagem para configurar e vai abrir a lista de repositórios dessa organização. Vou marcar o repositório primeiro_pipeline, que é o que estamos utilizando, atualizar a seleção e vou clicar no botão adicionar variável. Quando eu faço isso, essa variável de organização passar a estar disponível e se eu voltar ao trabalho do meu repositório, vou clicar em settings e vamos naquela barra lateral, em secrets and variables, e no menu actions, vamos clicar em variables aqui no menu ao lado, ver a listagem e nós temos agora aqui variável do ambiente de dev, variável de repositório e a variável da organização. Todas as três nós podemos visualizar o valor. E vamos testar essa variável no nosso pipeline? Vamos voltar aqui para o código. Vou abrir o código desse Pipeline. Vamos aqui neste primeiro passo do processo de build que nós estamos utilizando, vou substituir o valor para a variável da organização, aplicar essas alterações e vamos voltar em actions e executar esse pipeline. Vamos executar este workflow manualmente. Abrir a execução, clicar no log de build. E aqui nós temos o log do run one-line script. Vou clicar nele e agora temos "Hello, world!, ORGANIZACAO CURSO LINKEDIN". Ou seja, consumimos também a variável da organização.


 Reusable workflows: Entendendo e criando pipelines reutilizáveis - Parte 1
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Quando nós estamos trabalhando em um cenário de deployment de uma aplicação para um ambiente DevOps, onde nós temos diversas aplicações e diversos ambientes, essa é uma coisa muito importante com a qual nós temos que nos preocupar. Esse pipeline, por exemplo, que está aberto na tela neste momento, possui a configuração para um ambiente de deploy dev, que está apontando para um ambiente de desenvolvimento. Mas, no mundo real, quando estamos trabalhando com aplicações no nosso dia a dia, no ambiente produtivo, nós temos mais de um ambiente; É muito comum ter no mínimo três: desenvolvimento, ação e produção. Você pode ter vários outros, já passei por empresas com cinco, seis, sete, até mesmo oito ambientes para que a aplicação entre em produção, e isso tudo deve ser refletido nesse pipeline. E como é que nós fazemos isso? O modo mais comum é você vir nesse seu pipeline e copiar todo este bloco de código do deploy dev. E por que nós fazemos isso? Porque geralmente o deploy dessa aplicação, como ele é feito em dev, ele é realizado da mesma forma em homologação e em produção. Então copiamos este bloco, vou dar alguns ENTERs no final do arquivo, ajustar o ponto do meu mouse para seguir a orientação correta no começo do arquivo, e vou colar este novo bloco de código. Agora notem que nós temos esse deploy dev que nós acabamos de colar e subindo um pouco mais o deploy dev que já existia. Vamos no que acabamos de colar e esse nome então de deploy- dev para deploy-hml, que seria uma sigla para homologação, que é muito usada no nosso dia a dia nas empresas também, ok? Descendo um pouco mais, nós temos a configuração de environment, que aqui está desenvolvimento, mas só para ilustrar, eu não vou mexer nisso agora. Basicamente, nesse pipeline nesse momento nós temos dois ambientes onde será feito o deployment: deploy-dev e deploy-hml. Isso funciona, está certo, não é um problema ser desta forma. Isso começa a se tornar um problema quando nós não temos apenas uma aplicação ou apenas três ambientes para deployment, mas diversas aplicações. Imagine que você tem hoje na sua empresa 50, 60 microserviços que tem aí pelo menos três ambientes. Começa a entender onde está o problema? Quando você tiver que fazer uma manutenção desse seus pipelines, você vai ter que fazer essa manutenção em diversos locais diferentes e isso tende a ser muito problemático, porque você pode arrumar num lugar e esquecer do outro, e aí por consequência a sua aplicação vai ser implantada com problema, ou vai ser implementada errada, em local errado, com algum valor errado e isso pode te causar muitos prejuízos. Então, qual é a ideia aqui? A ideia é que nós não façamos dessa forma, mas que nós reutilizemos pipelines que eles estejam centralizados num local único, e, quando você precisar alterar isso, você altera num lugar só e reflete para todos os ambientes, isso se chama Reusable Workflow. E para nós utilizarmos isso, o que nós precisamos fazer? Eu vou na minha outra aba do GitHub, na parte de repositórios, e vou criar um novo repositório. Vamos descer um pouco a tela de true name. Eu vou chamar de "pipeline_templates". Esse nome está disponível. Eu vou deixar esse repositório como público. Vou adicionar também um README file e vou clicar no botão create repository. A partir disso, nós já podemos começar a trabalhar aqui. E eu quero apresentar para vocês uma questão muito legal, uma mágica que eu quero fazer com vocês, que é apertar o botão ponto final do meu teclado. Quando eu faço isso, vejam só o que acontece. É carregado na tela uma visualização muito similar ao que é o VSCode. Então nós temos uma experiência muito parecida com o VSCode, mas não se confunda, esse não é o VSCode completo. Você não tem, por exemplo, acesso a um terminal por aqui, não. É só uma interface gráfica mais simplificada para você trabalhar com os seus repositórios. Se você precisar de uma interface com terminal e tudo mais, você pode dar uma olhadinha no GitHub Codespaces, mas isso fica para um outro momento.


 Reusable workflows: Entendendo e criando pipelines reutilizáveis - Parte 2
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Então o que que nós vamos fazer aqui nesse momento? Vamos começar a criar então o nosso template de pipeline. Para fazer isso é um processo bem simples. Na parte de exploração desse nosso editor de código, que é muito similar ao VSCode, vamos criar uma nova estrutura de pastas para que possamos criar o nosso workflow. Então, botão de nova pasta e crie a seguinte estrutura que vocês já estão bem acostumados: ".github/workflows". Já que é dentro dessa estrutura que o GitHub reconhece pipelines, ok? Agora vamos criar um novo arquivo chamado "demo-deploy.yml". Lembrando que esse é o nome que eu estou dando para o meu arquivo, você pode dar o nome que você preferir, que fizer mais sentido para o seu processo, ok? Dentro desse arquivo que nós criamos, o que nós precisamos fazer? Para começar, nós precisamos definir a estrutura de triggers desse pipeline, porque sim, será executado baseado em uma trigger. Alguma coisa precisa acionar este pipeline. Então vamos começar incluindo a chave "on:" logo no começo do arquivo. Damos o ENTER em um TAB e agora nós definimos qual que é essa trigger, que é basicamente o "workflow_call:". Então nesse caso significa que este pipeline será executado quando outro pipeline chamá-lo. Isso significa que o workflow call. Além disso, nós podemos definir algumas coisas que podem ser muito úteis, como, por exemplo, variáveis que nós precisamos para executar o nosso pipeline. Imagine o seguinte, você está fazendo o deploy de desenvolvimento, deploy de homologação e deploy de produção. E aí podem mudar a estrutura de pastas, algumas variáveis e você precisa passar isso para o seu pipeline reutilizável. Então, para isso você precisa incluir o que nós chamamos de inputs. Então vou dar um ENTER, um TAB e incluir essa chave "inputs:". ENTER novamente. Vou dar mais um TAB para poder organizar a indentação e aqui eu vou declarar a variável que eu vou criar, a variável que eu vou precisar durante o meu processo. Que nesse caso eu vou chamar de variavel-demo. E também preciso dar dois pontos para que o GitHub reconheça. Vou dar um ENTER e aqui agora eu posso dizer se essa chave é obrigatória, incluindo a chave required, e ela eu posso citar true ou false, ou verdadeiro ou falso, que nesse caso true torna essa chave obrigatória; falso, ela fica opcional. Eu vou deixar como true mesmo, vou dar mais um ENTER e aqui eu posso indicar mais um ponto que pode ser muito importante, que é o tipo dessa variável. Então eu vou incluir a chave Type: e vou incluir o texto string, que é porque eu quero dizer que esta variável é do tipo string. Agora vou dar mais dois ENTER aqui. Vou levar meu marcador para o início do parágrafo novamente e vamos começar o pipeline de fato, porque até aqui foram só o processo de trigger e variáveis que serão utilizadas. Para isso, eu vou iniciar abrindo uma chave Jobs: vou dar ENTER e montar a orientação e vou incluir um job chamado de deploy. Você pode dar o nome que você quiser, eu estou dando o nome de "deploy:". ENTER, TAB. E agora eu preciso colocar onde esse pipeline vai ser executado, qual é o runner que vai executar. Então vou colocar aqui "runs-on: Ubuntu-latest". Vou dar mais um ENTER e agora nós podemos começar a declarar os nossos passos. Então para isso vou incluir a chave "steps:", ENTER e a partir daqui nós colocamos as actions de fato que serão executadas. Como nós já temos um pipeline configurado, eu vou voltar para minha outra aba, vou aqui em deploy dev e vou copiar os steps que estão dentro de deploy dev. Copiados esses steps, vamos colar ele dentro do nosso pipeline template. Temos a segunda action que é um run one-line script, ela vai escrever só um texto na tela, está escrevendo o Hello, World! e a variável dev. E temos outro que é um multi-line. Aqui onde está a variável dev, nós vamos mudar para poder fazer o quê? Usar o input que nós acabamos de criar. Então eu vou substituir este vars.VARIAVEL_DEV por inputs.variavel-demo. Vamos fazer um commit. E agora nós vamos fazer o quê? Vamos voltar para o nosso pipeline e vamos remover toda essa questão de steps do nosso pipeline. Vamos remover o environment e o runs-on, que nesse caso não é importante para o nosso teste, e vamos deixar apenas o needs: build, que é o que ele precisa para poder fazer a hierarquia do processo. Vamos dar um ENTER e aqui agora nós precisamos incluir uma nova chave, que é a uses, que isso indica que ele vai usar um pipeline externo. E aqui nós vamos incluir o nome da nossa organização ou o nome da sua conta, se tiver usando a sua conta pessoal, que no meu caso é demolinkedin, barra o nome do repositório, Pipeline_templates, barra a estrutura do arquivo, então.github/workflows, barra o nome do arquivo, que no nosso caso é demo_deploy.yml. E aí nós precisamos colocar um @ e a versão deste nosso pipeline, do nosso repositório. No meu caso, eu estou usando a branch main, mas você pode usar a branch que você estiver usando ou o ID de commit que você estiver usando, se quiser ser mais preciso, ok? E aqui agora eu vou incluir outra chave, que vai ser a "with:", ENTER, ESPAÇO, e declarar a variável que nós criamos também, "varavel-demo:", vou abrir aspas para colocar no texto, "Demo Dev", e aí eu vou fazer um commit dessas minhas alterações. Ah, não tem algo errado aqui. Deixa eu ver aqui. Voltando aqui podemos ver que está uma linha vermelha porque tem um erro de ortografia e ele não está encontrando esse arquivo, então vamos colocar aqui o github/workflows e agora ele está encontrando, está tudo certo. Podemos fazer o commit das nossas alterações. Então a gente pode ver ali que é importante que isso esteja certinho para que ele reconheça o nosso pipeline. Estando aqui, nós podemos agora ir em actions e rodar o nosso pipeline manualmente. Vamos abrir aqui para ver a execução. Podemos ver o processo de build que já está rodando. Ele é rapidinho, bem simples. Já vai entrar o de deploy e vamos ver o log do processo de deployment? Vamos ver aqui que já estamos usando no processo de setup job, vamos voltar aqui, nós conseguimos ver que ele está fazendo a utilização do nosso template e se visualizarmos a task de run one-line script, ele escreveu Hello, World! Demo Dev, ou seja, está tudo sendo feito da maneira conforme nós esperávamos.

 Reusable workflows: Entendendo e criando pipelines reutilizáveis - Parte 3
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Uma outra questão muito pertinente é quanto a reusabilidade dos nossos pipelines. Nós já aprendemos como criar pipelines reutilizáveis que serão armazenados no repositório central e basicamente instanciados em outros pipelines. Isso é muito útil quando nós já conhecemos a estrutura, quando nós já conhecemos o processo e sabemos que precisamos utilizar aquele pipeline reutilizável que está naquele repositório. Mas imagine que você tem pessoas novas entrando no seu time, pessoas desenvolvedoras novas no seu time que precisam criar pipelines e não sabem que já existe todo um padrão e todo um workflow para isso. Como é que você pode indicar para essas pessoas utilizarem o padrão que você gostaria? Isso pode ser feito de uma forma muito simples. Basta você criar um template de um pipeline reutilizável e aí ele aparecerá nesta tela de quando nós vamos criar uma nova action. Aqui nessa tela de uma nova action, o pipeline sugerido para esse repositório, sugestões de deployment e vários outros. E nós podemos incluir nossas próprias sugestões aqui, sugestões da nossa organização que vão utilizar os pipelines reutilizáveis que nós já criamos e seguir assim todos os nossos padrões de manutenção de boas práticas e tudo mais. Como nós fazemos isso? Bom, vamos aqui para nossa organização, vou abrir na próxima aba aqui, e aqui na nossa organização, o que que eu vou fazer? Eu vou ver em repositórios, vou clicar em new repository, e vou criar um repositório chamado.github. Esse repositório até dá um alerta aqui na tela que é um repositório especial, porque com ele você pode um README para sua organização, e todas as pessoas que acessarem a sua organização verão esse descritivo. Mas ele não é especial só por isso. Esse repositório.github te permite criar várias coisas como padrões para sua organização. Como, por exemplo, padrões de pipelines ou padrões de issues. Descendo aqui a tela um pouquinho, eu vou manter esse repositório como público, vou adicionar um README file e vou criar este repositório. Então agora nós temos o repositório criado e eu vou fazer aquela mágica do ponto final. Então, bom, temos aqui o nosso editor simples do VSCode com nada dentro, e o que que nós precisamos fazer para que tenhamos este nosso template de pipelines? Eu vou criar uma pastinha chamada workflow-templates. Workflow-templates, está escrito certinho, ENTER, e aqui dentro dessa pasta eu vou criar o nosso arquivo demo-deploy.yml. E aqui dentro vai a configuração do nosso pipeline propriamente dito. Eu vou voltar no meu repositório anterior, na outra aba, e vou visualizar o código dessa nossa action. Vou lá na pasta no arquivo, vou abrir e vou copiar todo este código. Vamos voltar agora no VSCode e vou colar ele inteirinho aqui. E agora eu vou fazer o quê? Eu vou modificar o nome, você pode colocar o nome que você quiser, eu vou colocar o nome de demo-deploy. Aqui abaixo, na parte de triggers, eu não preciso mudar nada, eu posso deixar as minhas triggers padrões, posso inclusive construir outras triggers que forem necessárias. Tenho aqui o meu processo de build, não preciso fazer nada. Eu vou remover só a parte da variável aqui. Descemos aqui o nosso processo e temos o deploy dev configurado. O que eu vou fazer aqui? Eu vou só incluir mais um outro valor de igual o deploy dev. Eu vou chamar de deploy hml e vou colocar que ele depende de deploy dev. Não vou mexer em nada além disso aqui nesse arquivo, porque basicamente é isso que é um template de pipeline reutilizável. E aqui eu preciso incluir um outro arquivo que é um arquivo de suporte a este template. Então vamos aqui nessa mesma pasta adicionar um novo arquivo, que ele contém o quê? O mesmo nome que esse, "demo-deploy", precisa ser exatamente igual, ".properties.json", porque ele é um arquivo de properties auxiliar a este nosso pipeline. Como ele é um JSON, vamos abrir chaves aqui e fechar. E ele depende de dois parâmetros obrigatórios, você pode incluir alguns outros, mas estes são os obrigatórios. "name": "Pipeline Demonstração". E eu vou colocar outro aqui, que é o ""description": "Pipeline Demonstração'Dev". Vamos salvar e agora vou fazer o commit deste nosso processo. Inclusão de template. Commit and push. E agora, se deu tudo certo, vamos voltar lá para o nosso repositório onde temos o nosso primeiro pipeline. Vamos clicar aqui no menu de actions e clicar aqui no botão new workflow. Vamos descer a tela aqui um pouco para escolher o workflow. E agora nós temos aqui um by demolinkedIn, que é a nossa organização. Nós temos o pipeline demonstração, que se eu clicar em configure, ele já vai trazer aqui um pipeline de exemplo com as configurações que nós definimos, o pipeline inicial e abaixo o ambiente de dev de homologação, ambos usando o pipeline reutilizável que nós criamos.

 Passando parâmetros para o pipeline
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Mais uma forma de te ajudar aqui no processo dos pipelines é a inclusão de parâmetros na execução desse pipeline, porque é possível que você precise setar alguma coisa, alguma informação no momento da execução desse script para te ajudar. Seja, por exemplo, uma versão de um.NET, algum caminho de arquivo ou algum texto de exemplo, por exemplo, você pode querer setar isso durante o tempo de execução e você pode sim fazer isso com o GitHub de uma forma muito simples. Nesse nosso pipeline de exemplo aqui eu vou editar este arquivo, e aí, aqui em Workflow Dispatch, nós vamos fazer o seguinte: Nós vamos adicionar aqui, dar um TAB e adicionar a chave inputs. Aqui dentro de inputs eu vou colocar valor-exemplo. E aí eu vou colocar aqui "required: true" e "type", eu vou colocar aqui como string. Isso aqui vai me permitir setar um valor de exemplo toda vez que eu enfileirar este pipeline. E aí eu posso vir aqui, Commit changes, e agora, quando nós formos aqui em actions, nesse pipeline de CI, em Workflow, ele pede para eu passar este valor de exemplo e assim nós conseguimos ter esse valor, esse parâmetro disponível dentro do nosso pipeline.



O que são os runners
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Quando vamos executar um pipeline no GitHub Actions, é muito comum utilizarmos os Runners. Geralmente nos pipelines de teste que criamos vem lá um Runs on Ubuntu-latest. Basicamente, este é um runner. Mas o que de fato seria isso? Um runner basicamente é um agente de execução do GitHub Actions, permitindo que os seus pipelines sejam executados, ou seja, é um serviço instalado em um servidor, em um container, em um ambiente qualquer que você tenha, que te permite realizar todos esses processos de automação pra compilação, build, deployment. Todos os processos de automação dependem desses runners instalados no seu ambiente.

Habilitar transcrições interativas




Runners hosted x self-hosted
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
No GitHub Actions, nós temos dois grandes tipos de runners disponíveis. O primeiro deles é o Hosted Runner, que é um runner hospedado pelo próprio GitHub. Nele, o GitHub fornece ambientes Windows, MacOS e Linux para que você possa realizar o seu processo de compilação de build e deployment. Já o ambiente Self Hosted é um ambiente no qual você mesmo hospeda os seus próprios runners na sua infraestrutura, ou seja, você vai ter um servidor ou a sua máquina onde você instala esses serviços que esse serviço irá se comunicar com o GitHub. Para automatizar o processo dentro da sua infraestrutura. Então, se você tem um ambiente de build deployment on premises com o GitHub, é dessa forma que você consegue utilizar isso.

Habilitar transcrições interativas


Sistemas operacionais suportados pelo self-hosted runner
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
No caso do ambiente Self-hosted, você pode instalar isso dentro do seu próprio ambiente. Entretanto, todas as responsabilidades de software instalados, dependências, CLA, tudo que você precisa para sua aplicação rodar fica aos seus cuidados. Então você precisa se responsabilizar a instalar todas as dependências. E nesse ambiente no qual você mesmo instala dentro da sua própria infra, quais ambientes seriam suportados? Bom, o primeiro deles basicamente é o Windows. Então você consegue ter seu servidor Windows, rodar sua aplicação, buildar, fazer o deployment sem maiores problemas. Se o seu ambiente é Linux, você também tem suporte a isso. Basta você fazer as configurações e instalações. E caso você precise de um ambiente MacOS, você também consegue fazer isso dentro do Mac sem maiores problemas. Então hoje o GitHub Actions suporta dentro dos seus Runners Self-hosted, Windows, Linux e Mac.

Habilitar transcrições interativas



Instalando runners no macOS
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos agora instalar um New self-hosted runner, só que dessa vez num ambiente Mac. Então vamos clicar no botão New self-hosted runner. E visualizar que o nosso image é macOS, e nós precisamos aqui selecionar a arquitetura x64 ou ARM64. No meu caso, eu estou utilizando um MacBook M3, então ele já usa a arquitetura ARM64 e é essa que eu vou usar. E vejam aqui que nós temos já os comandos específicos. Vamos começar pela primeira parte, que é onde ele cria o diretório e nos coloca lá dentro. Vamos para o segundo, que é onde ele realizará o download do binário. Vamos executar então o nosso curl para realizar o download deste nosso runner. Download realizado. Vamos validar o nosso hash, ver se está tudo ok. Ok. Então nenhum dado foi corrompido. Vamos copiar o último comando desse bloco de download, que é a extração dos dados. Dados extraídos. Vamos voltar e descer um pouco a tela para a aba de configuração. Vamos copiar este comando do config.sh. Vamos executá-lo. Vejam que nós estamos no passo de autenticação, passo de configuração. Como nós já vimos nos demais, precisamos incluir o nome do grupo ou deixar o default. Vou deixar default. Podemos usar o nome sugerido ou especificar algum. Vou deixar sugerido, que é o nome do meu Mac. E aqui ele já está identificando algumas labels como self-hosted, MacOS e ARM64. Você pode adicionar mais alguma que faça sentido para o seu projeto. Eu vou deixar dessa forma mesmo. O runner foi adicionado e algumas outras configurações do próprio Runner. Aqui é o diretório onde ele trabalha. Eu costumo não mexer nessa parte, ok? Eu deixo ele funcionar da forma que ele já está acostumado e previsto, que é dentro do diretório _work. E as configurações foram salvas, vamos voltar na outra aba e vamos no último passo executar este nosso Runner.sh conectado ao GitHub e está escutando por trabalhos. Vamos voltar ao GitHub. Descendo um pouco, nós podemos visualizar a forma de usar, que basta colocar a tag self-hosted ou nós podemos também colocar as labels, mas vamos voltar na parte de runners e nós podemos ver agora que temos também nosso Runner MacOS disponível dentro do nosso repositório.

Habilitar transcrições interativas




Self-hosted runner: Repositório x organização
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Nós configuramos alguns runners dentro desse nosso repositório do GitHub Actions e eles funcionam muito bem para automatizar o seu processo e executar as suas compilações. Mas existe uma questão bem importante. Estes runners estão disponíveis única e exclusivamente para este repositório. Se você tiver algum outro repositório na sua organização que precise utilizar este mesmo runner, você não vai conseguir. E como que nós vamos resolver essa situação? Bom, para isso nós precisamos instalar um runner baseado na organização. Para isso, nós vamos acessar a nossa organização. Então, no topo da tela, onde nós podemos visualizar o nome da organização e do repositório, vou clicar lá. Clicando na organização, aparece a tela de descritivo da sua organização e vamos entrar em settings. Em settings, no menu lateral, vamos encontrar a mesma opção que vimos no repositório de actions e aqui temos algumas opções voltadas a Runners e Runners Group. Primeiro vamos entrar em Runners Group. Em Runners Group é onde nós podemos criar vários grupos para os nossos runners. Então imagine que você tem um grupo para aplicações Java, um grupo para aplicações.NET, ou um grupo para deploy on Azure e um grupo para deploy on premise. Você consegue fazer todos esses tipos de agrupamento. Eu não consigo criar um grupo novo aqui porque a minha organização é uma organização gratuita, mas se você estiver usando uma versão paga do GitHub, você consegue criar novos grupos aqui sem maiores problemas. Vamos só dar uma olhada nesse grupo de runners group, que já existe aqui. Então vou clicar em Default e nós podemos visualizar algumas informações como o nome do grupo, que nós podemos alterar. Descendo um pouco mais, nós temos quem consegue acessar, quais repositórios conseguem acessar este grupo de runners. A princípio está todos os repositórios, mas você pode vir e selecionar apenas alguns. Da mesma forma que nós configuramos variáveis e secrets, nós podemos configurar aqui também. Então basta clicar na engrenagem e selecionar quais repositórios terão acesso a estes grupos. Eu vou voltar a configuração inicial de todos os repositórios. E um pouco mais abaixo desta caixinha nós temos uma informação de "Permita que repositórios públicos utilizem isso". Os runners podem ser utilizados por repositórios públicos, permitindo que self-hosted runners alcancem repositórios públicos e permitindo workflows em pipelines de forks, por exemplo. Isso pode trazer um risco, então você precisa pensar se habilita ou não. Descendo um pouco mais, você pode configurar quais workflows podem ser executados com esse runner e mais abaixo nós podemos visualizar quais runners fazem parte deste grupo, que, no nosso caso, nenhum faz. Nós podemos adicionar um novo runner por aqui ou clicando na opção de runners na outra tela. Vamos criar por aqui mesmo em New runner. E nós temos a opção de New self-hosted runner, que é o que nós criamos para o nosso repositório, ou uma opção que só está disponível para Times ENTERprises, que é um novo GitHub-hosted runner, onde você configura o seu próprio runner dentro da infra do GitHub, como se fosse um hosted pelo GitHub, que basicamente é isso, um host pelo GitHub, mas sobre o seu domínio sobre o seu controle. Vamos aqui em new self-hosted runner. E basicamente aqui o processo é o mesmo. A única diferença é que, se você criar um runner por aqui, ele ficará disponível para vários repositórios, e, se fizer exclusivo para repositório, outros projetos não enxergam ele. Então você precisa pensar se você precisa que esse runner atenda outras necessidades, crie a nível de organização. Se for um caso muito específico, pode criar apenas no repositório.

Habilitar transcrições interativas

 Utilizando um self-hosted runner no pipeline
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Para utilizar os nossos hosted runners que foram configurados em nossa infra, é bem fácil, porque nós temos apenas que mudar uma simples configuração dentro do pipeline. Já estamos no processo de edição e nós podemos encontrar dentro do job de build o processo runs-on. Atualmente, ele aponta para o Ubuntu-latest, que é um runner hospedado pelo GitHub, mas nesse caso nós queremos usar o nosso. O que eu preciso fazer aqui? Eu posso simplesmente mudar a label para self-hosted. Nesse caso, o GitHub já identifica que é para utilizar um runner nosso privado, mas ele vai executar em qual estiver disponível naquele momento. Vamos voltar na outra aba para os nossos runners. Por exemplo, neste caso nós temos dois runners. Um está online, o outro está offline, mas nós temos dois ambientes diferentes, um Windows e um Linux. Como é que eu faço para especificar o que eu quero que vá no self-hosted e que vá no Linux? Para isso, vamos voltar na aba do pipeline. Eu posso criar aqui uma combinação de chaves dentro desse runs-on para que eu possa identificar qual é o pipeline que eu quero. Então vou colocar "self-hosted, Linux" e fecho a chave. Nesse caso, ele sabe que tem que pegar um self-hosted que tenha também a label Linux. Vamos então realizar o commit dessas alterações e executar este nosso pipeline. Vamos voltar então no menu de actions, clicar em CI e executar este workflow. Vou clicar aqui nessa execução, abrir os logs do processo de build e neste caso ele está demorando um pouco mais para configurar porque é o meu ambiente private, ou seja, ele está indo dentro do meu ambiente, já executou e, se expandirmos o setup job, nós podemos visualizar que o runner que executou este processo foi o srv-ubuntu-docker-lab, ou seja, o meu ambiente on premise. Então, voltando aqui a aba dos Runners, nós podemos simplesmente configurar baseado em cada uma dessas labels, e se você precisar de mais labels, você pode customizar cada uma delas. Eu vou clicar neste runner que acabamos de executar o processo e nós podemos ver aqui que não tem nenhum job rodando, ma,s se tivesse, nós conseguiríamos acompanhar aqui também.



Planejando um pipeline de CI /CD
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos então agora planejar um pipeline de CI/CD. O que nós precisamos para planejar o nosso pipeline de CI/CD? Basicamente, precisamos definir o nosso processo. E, com isso, vamos definir então o primeiro passo do nosso pipeline, que seria o processo de build. Dentro do processo de build, nós contamos com algumas coisas, como compilação, testes unitários, análise de qualidade e geração de artefato. Podemos conter mais algumas coisas dentro de um processo de build, mas geralmente este é o mínimo necessário para que isso tudo funcione. Então tem compilação, testes unitários, análise de qualidade e geração de artefato. Tudo isso é crucial para esse pipeline seguir adiante. Quando nós vamos olhar para o processo de deployment, o que mais se torna necessário também? Quais serão os ambientes que nós vamos realizar este nosso deployment? Será necessária a aprovação de alguma pessoa? Vai ser necessário também criar recursos de infraestrutura? E configurações de ambiente precisarão ser feitas? E também como será realizada a implantação da nossa aplicação. Esses aqui também são os passos mais comuns que nós precisamos nos atentar quando estamos desenvolvendo o processo de deployment da nossa aplicação. Ambientes são essenciais, é importante você saber se vai ter alguma aprovação ou não, isso geralmente entra no ambiente de produção ou algum ambiente mais controlado. Criação de recursos de infra também é bastante comum quando você está usando o cloud. Configuração de ambiente também, temos vários casos muito interessantes de configuração de ambiente para ambientes de dev ou para caso de blue/green deployment, entre outras coisas. E a implantação da aplicação em si, que é onde você vai colocar os seus binários, aplicar algumas configurações extras necessárias. Pontos importantes durante este planejamento. Nós podemos ter alguns processos extras, que seriam o quê? Testes de fumaça nesse ambiente, testes de segurança e também o monitoramento da nossa aplicação. O teste de fumaça é um teste bem simples, basicamente para você saber se a sua aplicação subiu ou não. Então você vai lá, testa o endpoint retornou 200, está tudo certo. Testes de segurança, entram para o teste de vulnerabilidade, Pentest, entre outras coisas. E o monitoramento também, que é essencial para que você possa saber da saúde da sua aplicação, se está tudo certo, se não está, se está tendo problemas, se está encontrando bug, para que você possa ser proativo, ser proativa neste cenário. E então, como vai ser o nosso processo nesse nosso curso de GitHub Actions? Primeiro, nós teremos o processo de build para uma aplicação simples. Nós teremos, em segundo passo, a configuração desse ambiente e, em terceiro, nós teremos o deployment. Então nós vamos seguir aqui com um exemplo simples de pipeline com build, configuração de ambiente e também deployment da nossa aplicação.

Habilitar transcrições interativas


 Criando um build e gerando artefatos
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Agora, então, vamos criar o nosso processo de build para uma aplicação real, para que nós possamos configurar todo o processo de build e deployment. Bom, eu tenho aqui esse repositório, que eu já criei previamente, onde eu tenho uma aplicação simples em.NET, que é uma aplicação web. Vamos descer a tela aqui um pouquinho para que vocês possam visualizar um pouquinho dessa aplicação. Ela é uma aplicação bem simples, onde basicamente vai abrir uma tela que vai carregar o mascote do GitHub e esse mascote vai mudar toda vez que você atualizar a tela. Uma aplicação bem simples, apenas para que possamos realmente fazer esse processo. Vou subir a tela novamente e agora vamos então editar este código. Eu vou utilizar o GitHub Codespace. Você pode utilizar o seu VSCode ou mesmo o editor direto dentro do GitHub. Eu vou clicar aqui em code, no menu de codespaces, e vou criar um novo Codespace para mim. No meu caso já está criado, então, basta eu clicar no link que está aqui e será aberto o meu Codespace, que já está na minha outra aba. E esse é o GitHub Codespaces, onde carrega sua aplicação e ele é o VSCode completinho. Para você poder visualizar o que que é essa aplicação que eu tô falando, não ficar só naquele print, eu vou executar no meu terminal... Sim, eu tenho acesso ao terminal, um "dotnet run". E aqui vai fazer o quê? Vai mudar minha aplicação, restaurar pacotes e disponibilizar um link para acesso externo. Então aparece uma caixinha na parte de baixo da tela onde eu posso clicar em "open in browser" ou "abrir no meu navegador". Então basta clicar nesse botão, vai abrir uma nova aba onde você pode visualizar a aplicação, que já está, inclusive, mostrando o mascote do GitHub aqui. Se eu atualizar a tela, outro mascote aparece. Se eu atualizar a tela, outro mascote aparece. Eu acho que vocês entenderam a questão. Vou fechar essa aba, vou dar um CTRL+C no meu terminal para parar esta seção e eu vou criar então meu pipeline do GitHub Actions, ok? Só que eu vou utilizar uma ajudinha bastante interessante e conveniente aqui, que é o GitHub Copilot. Se você já tem a licença do GitHub Copilot e quer utilizar, basta você acessar o menu lateral do GitHub ou do VSCode, no meu caso Codespaces, e clicar no menu Extensions. Em extensions, você procura pela extensão GitHub Copilot e instala na sua IDE de preferência e você vai conseguir utilizar. Vai precisar se autenticar no GitHub, ter a licença e consegue utilizar. Vou voltar para o menu de arquivos, então vamos seguir na criação desse pipeline. Vou então aqui criar uma nova estrutura de pastas, como vocês já estão bem acostumados. Criando então uma pastinha chamada.github, e uma subpasta chamada workflows. Dentro desse diretório, vou criar o quê? Um arquivo.YAML, que eu vou chamar de "pipeline.yml". E com o pipeline aberto, agora eu preciso pedir então para o GitHub Copilot me ajudar. E eu vou fazer o quê? Eu vou abrir uma linha de comentário, neste caso YAML, com o jogo da velha, e vou colocar o quê? "Crie um pipeline para uma aplicação .Net 6 em GitHub Actions", e ele já começa aqui a sugerir. Eu vou dar um TAB para aceitar, vou dar um ENTER e agora já está me sugerindo as triggers para push na branch main, pull request na branch main, os jobs. Vamos aceitar e visualizar o que ele sugeriu. Vamos descer um pouco a tela. Me sugeriu o passo de checkout. Ok. Vou apenas atualizar a versão de "v2" para "v3", porque eu sei que esta action mudou de versão. Descendo um pouco aqui temos o passo de setup.NET, que também está ok, apontando para a versão 6, mas está apontando para uma versão muito específica de preview. Vou remover essa parte do ".100" em diante e vou substituir por "x", e aí a task vai saber identificar a melhor versão para a aplicação. Descendo aqui, nós temos o passe de dotnet restore, está tudo certo; dotnet build, está tudo certo; dotnet test, eu não preciso. Temos também o dotnet publish. Para essa aplicação específica, eu vou tirar o configuration release, e aqui, só para explicar, esse passo está servindo para gerar o pacote, o artefato que nós utilizaremos para deployment. Esse passo aqui, ele está adiantando o processo querendo fazer o deployment aqui, eu vou ignorá-lo e vou incluir aqui, ó, "inclua um upload do artefato". E aqui já entendeu, basta eu aceitar a sugestão. Vou tirar esses três aspas que ele sugeriu aqui embaixo, que isso é uma coisa de Markdown. Então ele já sugeriu aqui o upload do Build Artifact apontando para a pasta publish, está certo. Então vamos voltar ao menu lateral do nosso VSCode e realizar o commit deste pipeline. Realizar o commit, "yes", e agora sincronizar as alterações para mandar isso para o repositório. Ok? Vou voltar para o repositório na outra aba e vou clicar no menu de actions. Já temos o nosso pipeline rodando, vamos clicar nele aqui. Lembrando que ele está rodando por causa da trigger que nós colocamos para ser no push para a branch main. Vou clicar em build para ver os logs, e temos aqui fazendo o checkout, configurando.NET, instalando dependências, realizando build e agora está publicando o artefato. Pipeline finalizado, vamos voltar aqui em Summary. E olhando aqui em Summary, nas opções que o GitHub mostra do log de execução, nós podemos ver quem fez o push, nós podemos visualizar o status, podemos visualizar o tempo e também que existe um artefato. Descendo um pouco a tela, nós podemos visualizar os artefatos existentes, poderíamos excluir se quiséssemos ou se clicar aqui, "baixar este artefato".

 Incluindo um novo job associado a um environment
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Agora que já temos nosso pipeline de build funcionando, gerando o nosso artefato, vamos então incluir um novo job aqui, para que nós comecemos a configurar o processo de deployment, certo? Então, ao GitHub Copilot para que "inclua um job de deployment". Vamos ver o que ele vai fazer. Ele já incluiu um processo. Vamos dar uma olhada. Processo de deploy necessita do build, interessante, já fez o workflow, vai rodar no ubuntu-latest e tem os passos aqui de baixar o artefato, só que ele sugeriu toda uma questão de.NET, o que não é necessário para este caso, então eu vou remover este passo do.NET. Posso deixar esse deploy do Azure? Eu vou tirar também esse deploy do Azure por hora, e aqui, ele está fazendo então o download deste artefato. O que mais eu quero fazer aqui? Eu quero atrelar este job a um ambiente, certo? Então voltemos ao nosso repositório, vamos ao menu de settings > menu lateral, vamos até Environments. Em Environment, vamos clicar em Novo Environment e criar aqui "desenvolvimento". Configure Environment. Vou colocar revisores obrigatórios e vou colocar o meu usuário, porque eu não quero que isso execute de forma automatizada. Vou desabilitar o allow do bypass para que ninguém sobrescreva essa regra e vou salvar. Agora, então, temos um ambiente desenvolvimento. Vamos voltar ao pipeline e, logo depois de needs, vamos incluir environment. E aqui, em vez de production, que ele sugeriu, vamos colocar "desenvolvimento". Então temos um novo environment aqui configurado, atrelado, a desenvolvimento. Ele está completo? Não. Por quê? Porque ele precisa de toda uma configuração para que possamos fazer um deploy no Azure. Vamos então configurar a parte do Azure e aí nós voltamos aqui para seguir com essa configuração.



Configurando um deployment no Azure
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Eu criei aqui no meu Azure um Web App para que nós possamos publicar a nossa aplicação no GitHub Actions. Para utilizar isso, o que nós precisamos fazer então? Voltemos ao nosso pipeline. Nós temos aqui o nosso artefato já gerado e precisamos publicar isso no Azure. Eu tenho numa outra aba aberto a action do GitHub Web App, que nós utilizamos para fazer o deployment. Vamos descer aqui a tela um pouco. Aqui tem toda uma explicação de como utilizar essa task, então vamos entender um pouco. Tem toda uma explicação, temos aqui alguns exemplos que nós podemos seguir, mas ele já traz alguns exemplos na tela. Então nós podemos visualizar um exemplo para Node.js, Node.js conteinerizado. Aqui é um pouco mais do que nós precisamos. Um workflow de Node.js, apesar de ser Node.js, mas nós conseguimos adaptar isso para o.NET, mas aqui tem o fluxo que nós vamos ter que seguir mais ou menos, porque, primeiro passo, nós teremos que realizar o login do Azure via CLI. Então vamos copiar esse passo para o nosso pipeline, indentação está ok, e o próximo passo basicamente é o deploy do web app. Vamos copiar esta linha aqui e vamos colar aqui embaixo. No app-name, nós precisamos dar o nome da nossa aplicação. Vou voltar no meu Azure e o nome da minha aplicação é demolinkedin. Copio esse nome, volto e colo no app-name. Aqui embaixo tem que colocar uma outra questão, que é o package, para que ele entenda onde está o pacote e realize o deployment disso no meu Azure. Agora só tem uma única questão que é bastante importante. Como a autenticação vai funcionar? Aqui, estou passando nesse passo de login uma secret chamada "AZURE_CREDENTIALS". Vamos copiar este nome, voltar ao repositório, e aqui, pode ser na área de environment, nós vamos criar uma nova Environment Secret com o nome "AZURE_CREDENTIALS". Vamos voltar agora na aba do Azure web app, do Marketplace. Descendo aqui um pouco, nós temos toda uma configuração, uma linha de comando que nós podemos executar para que o GitHub consiga ter acesso a este recurso. Vamos copiar aqui e vou abrir o meu Azure. Temos na barra superior uma opção que é um terminalzinho, que nós chamamos de Cloud Shell. Vou clicar nele e ele vai abrir um terminal no meu Azure para que nós possamos executar este nosso comando. Eu vou colar ele aqui na tela. Comando na tela, vamos fazer as substituições necessárias nas variáveis. Primeiro, nós precisamos substituir o sp-name, que está com o nome de exemplo. Vamos colocar aqui "demo-deploy-linkedin". Logo abaixo nós precisamos substituir também o quê? O ID da subscription. Deixa eu retirar aqui e vou pegar a minha... o meu ID de subscription no meu Azure, vou colar. Ele também pede aqui qual que é o ResourceGroup. O Resource Group nesse caso é demolinkedin e o app name também é demolinkedin. Vamos dar um ENTER, e a minha chave de acesso foi criada. Basta eu copiar este valor, voltar no meu GitHub, na parte de secrets, e armazenar este valor. Secret adicionada, voltemos ao nosso pipeline, acredito que esteja tudo certo. Vamos então realizar o commit disso. Incluindo.

Habilitar transcrições interativas

 Deployment: Aprovando e obtendo status badge
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos então realizar o commit. Yes. sincronizar as alterações e vamos voltar ao nosso repositório no menu de actions. Pipeline já está rodando com o passo de inclusão do deployment, processo de build rodando, vamos clicar para acompanhar o log, onde nós temos configuração .NET e todos os passos que já estamos esperando. Processo de build concluído, vamos clicar em Summary. O processo de deployment está aguardando nossa aprovação. Vamos clicar em Review Deployment, nesse novo menu que aparece na tela. Vamos marcar a caixa "desenvolvimento" e aprovar o deployment. Então, vou clicar em deploy para acompanharmos o log e vermos se está tudo funcionando corretamente. Pipeline realizado com sucesso! Podemos expandir, inclusive, o log aqui. Acompanhamos que deu tudo certo e a URL da nossa aplicação está disponível. Se nós clicarmos aqui em "demolinkedin.azurewebsite.net", vai carregar o site para nós, pode demorar alguns instantes por ser o primeiro carregamento após o deployment, e nossa aplicação está de pé. Se atualizarmos a tela, nosso mascote continua mudando também. Então, voltemos para a nossa aplicação, para o nosso repositório, e aqui nós podemos obter uma informação bastante importante. Nós podemos obter os status badges dos deployment da nossa aplicação. Para isso, basta nós acessarmos o menu superior próximo ao botão Re-run all jobs, onde executamos todos os jobs. Vai ter um botãozinho com três pontinhos, você clica nesse botão e create status badge. E, nesse caso, nós temos uma tela que se abre onde nós podemos pegar a badge baseado numa branch. Nós podemos pegar um evento, vamos pegar o Default, e ele gera um código em markdown, que você pode copiar, que vai basicamente gerar a imagem que está no topo dessa tela que foi carregada, mostrando o nome do pipeline e o status, se esse pipeline passou ou não. Isso serve para você incluir no markdown, no README do seu projeto. Voltando aqui para o Codespaces, eu vou abrir o nosso README. Por aqui não, vamos entrar no menu de arquivos na barra lateral e achar o arquivo README.md. E eu vou incluir no topo da tela a nossa README, ou a nossa badge, basta colar, é um Markdown, e eu vou abrir o preview aqui do lado. Não vai funcionar. Bom, o preview não funciona no Codespaces, então vamos salvar e realizar um commit no repositório, "incluindo badge", vamos realizar o commit. Vamos sincronizar a alteração. E, voltando para o repositório, vamos acessar a barra de código, descer um pouco a tela e temos a nossa badge gerada aqui. Isso pode ser muito útil para você acompanhar a sua aplicação. E outra informação muito útil é que no menu lateral do seu GitHub, onde você consegue ver informações sobre o seu repositório, você também passa a conseguir visualizar informações sobre o seu deployment. Nesse caso, nós temos o ambiente de desenvolvimento. Se você estivesse outros ambientes, eles apareceriam aqui também com status de sucesso ou falha.



Explorando o GitHub Packages
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
O que seria então o GitHub Packages? O GitHub Packages é uma plataforma para publicação e gerenciamento de pacotes. Esses pacotes são aqueles que nós costumamos usar nas nossas aplicações quando estamos desenvolvendo, que são eles: pacotes NPM, pacotes NuGet ou até mesmo imagens Docker. Então o GitHub Packages é um local onde você pode centralizar e publicar as suas imagens privadas dos seus projetos, sejam eles públicos ou privados.

Habilitar transcrições interativas




Criando um pipeline para publicar pacotes NuGet - Parte 1
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos agora então criar um processo de pipeline que irá implementar o nosso pacote NuGet dentro do GitHub Artifacts. Eu tenho aqui então criado um projetinho simples em.NET, que é uma biblioteca de classes que vai poder gerar este nosso pacote para que nós possamos trabalhar desta forma. Para que isso funcione, nós precisamos primeiro ajustar o csproj deste projeto para que ele seja reconhecido como um pacote NuGet. Então estamos aqui dentro do arquivo demo-nuget.csproj, que é o nome do arquivo que eu criei. Se o seu projeto tiver outro nome, busque o arquivo csproj dentro do seu repositório, vai estar no explorador de arquivos ao lado. Dentro do csproj, nós precisamos incluir algumas propriedades para que ele entenda que é um pacote. Então eu vou dar um ENTER logo após a linha no label, no meu caso, mas vai ser antes de fechar a chave PropertyGroup. E vou incluir aqui uma nova chave denominada PackageID. Inclusive, o GitHub Copilot está nos ajudando, sugerindo o nome deste pacote. Logo em seguida, eu preciso da chave version, que o GitHub Copilot também já sugeriu. Authors. Nós podemos definir o seu nome ou o nome de outra pessoa que te apoiou. Eu vou deixar demo mesmo. Company. Também vou deixar o nome que ele está sugerindo. A descrição do pacote,. E outra coisa que nós precisamos. Eu não quero usar este que ele sugeriu não. Eu vou usar uma chave que é bem específica do GitHub, RepositoryUrl. Não é que seja específica do GitHub, mas ela é necessária para que haja uma identificação e mapeamento de que esse pacote faz parte desse repositório. E aqui então nós podemos colocar a URL da organização. Deixa eu voltar na outra aba onde está o meu repositório aberto, eu vou copiar essa URL que ele expõe aqui, que é o URL do repositório, vou colar dentro de RepositoryUrl e vou tirar apenas o nome do repositório. Ok. Temos aqui a configuração realizada para que a aplicação.NET entenda que é um pacote. Agora vamos então criar um pipeline do GitHub Actions para poder realizar essa criação. Então, vou criar aquela estrutura de pasta que já estamos acostumados. ".github/workflows", e dentro dessa estrutura, eu vou criar um arquivo.YAML, "pipeline.yml".

Habilitar transcrições interativas


 Criando um pipeline para publicar pacotes NuGet - Parte 2
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos então criar o pipeline que irá realizar a compilação e geração desse pacote e também a publicação dentro do GitHub Artifacts. Já estamos então com o arquivo em branco aberto e vamos utilizar o GitHub Copilot para nos ajudar a criar este pipeline inicial e depois nós realizamos apenas os ajustes necessários. Então, vou abrir aqui uma linha de comentário e vou pedir ao Copilot que crie um pipeline do GitHub Actions que irá compilar uma aplicação.NET 7 e publicar no GitHub Artifacts como pacote NuGet. Vamos ver se ele vai entender o que eu quero. Sugeriu um pipeline com o nome de.NET Core, ok. As triggers para a branch master. Eu vou alterar para main, mas vamos seguir a sugestão. Depois nós voltamos. Jobs. Já trouxe aqui o processo de deployment. Vamos ver aqui o que ele trouxe e fazer os ajustes necessários. Primeiro vamos trocar a branch para main nas triggers, já que não temos master nesse repositório e vamos ver os próximos passos. A execução no ubuntu-latest, a actions de checkout vou mudar para v3. Depois nós temos o setup do.NET Core e eu vou trocar a versão aqui de.NET, porque ele sugeriu a 3.1, sendo que eu pedi a 7, então vou colocar "7.0.x". Vamos ver mais abaixo. dotnet restore, dotnet build, dotnet test, e temos também o dotnet publish. No.NET publish eu vou fazer algumas alterações aqui. Ou melhor, eu não preciso do.NET publish, porque eu tô empacotando uma aplicação. Então eu vou tirar esta linha aqui. Eu vou tirar essas duas na realidade, porque ele está gerando também um Build Artifact, porque ele entendeu errado o que eu pedi. Eu vou pedir para que gere um dotnet pack do pacote NuGet. Então, ele agora sugeriu o.NET pack. Eu vou dar uma limpada nestes comandos, vou tirar o "no restore", vou deixar apenas o "configuration release" neste nosso caso. E agora, o que mais eu preciso fazer aqui para que ele entenda? Eu vou fazer um NuGet login. Vamos ver então se conseguimos que o Copilot faça isso. "Inclua um dotnet nuget add source para o github Artifacts". Ok? Então já teve o comandinho pronto: dotnet nuget add source. Precisamos incluir o nome do owner aqui, que é "demoLinkedin/index", "--name github --username". Vamos colocar aqui "demoLinkedin" e a senha GITHUB_TOKEN. Aqui é um ponto interessante. Estamos usando a GITHUB_TOKEN, então precisamos dar permissão para a GITHUB_TOKEN. Então vamos subir um pouco aqui, logo após runs-on, vamos dar um ENTER e incluir a chave permissions. E eu vou deixar contents, read e packages, write. E vamos descer novamente. E agora que nós temos o dotnet nuget add source, vamos adicionar um novo passo na próxima linha. Vamos pedir ao Copilot que inclua um dotnet nuget push, agora ele já entendeu. E vamos lá dar um TAB aqui. Dotnet nuget push. Vamos ver se precisamos alterar alguma coisa. Source github, duplicate, no symbols. E eu vou mudar apenas essa sugestão que ele incluiu de "env" aqui. Vou remover esta chave env, vou apenas copiar o valor da secrets GITHUB_TOKEN, mas vou remover essa linha de env. E então eu vou fazer um pequeno ajuste nessa linha de comando aqui, e vou colocar a chave "api-key", inclusive, ele até já sugeriu a GITHUB_TOKEN. Agora que estamos com isso pronto, vamos salvar. Realizando o nosso commit, sincronizando as alterações e vamos ver se o nosso pipeline vai rodar. Tô abrindo meu repositório na outra aba, vamos clicar no menu de actions. Nosso pipeline já está rodando, vamos clicar nele e vamos clicar no jobs de build para visualizar o log de execução disso aqui para ver se está tudo certo. Ele está rodando o setup.NET Core, vamos ver se os próximos passos vão ser ok. Precisamos fazer apenas um pequeno ajuste no comando de Add Source. Vamos voltar ao repositório. Aqui em add source, ele não suporta o armazenamento de senha encriptada, então para este caso, nós precisamos incluir uma outra chave extra, que é "--store-password-in-clear-text" E aí, dessa forma, provavelmente resolvemos aquele nosso erro. Vamos incluir um commit de correção. Ok. Sincronizar. E vamos voltar ao nosso repositório para visualizar o novo processo de build que está sendo executado. Vamos clicar em actions novamente, pegar a correção atual do pipeline e acompanhar os logs. Bom, o nosso pipeline deu um erro aqui, porque nós encontramos um probleminha de encriptação na senha. O.NET Core não suporta a encriptação da forma que o GitHub Copilot sugeriu para a gente. Então, nós precisamos voltar ao nosso pipeline e incluir a seguinte chave no passo de nuget add source. Eu vou incluir aqui a "--store-password-in-clear-text" Isso aqui vai fazer com que a senha não seja armazenada de forma criptografada, mas em texto plano. Vamos realizar o ajuste com o commit. Yes. E sincronizar as alterações. E agora vamos voltar ao processo para ver o nosso pipeline rodando. Vamos voltar no repositório, clicar em actions e pegar esta alteração que está sendo executada, entrar no job de build e acompanhar o log de execução. E agora nosso pipeline rodou todo com sucesso. Vamos voltar ao menu de code do nosso repositório, vamos descer a tela um pouquinho e nós podemos encontrar no menu lateral a opção de packages, onde nós podemos visualizar o nosso pacote já publicado. Se você clicar no link do pacote, você poderá ver mais informações sobre este pacote e como ser utilizado, ok? Outro lugar que você pode ver isso é você clicando dentro da organização e acessando o menu de packages. Aqui você consegue visualizar todos os pacotes publicados por esta organização.


 Criando um pipeline para publicar imagens Docker
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos agora então criar um Pipeline que vai pegar uma imagem Docker e subir isso dentro do GitHub Packages. Para isso, eu estou no meu repositório e vamos começar criando um arquivo Dockerfile. Esse arquivo Dockerfile, ele vai ser um Dockerfile bem simples. Inclusive eu já tenho um de exemplo que nós podemos utilizar. Então deixa eu colar o conteúdo aqui. Essa é uma imagem bem simples que está usando uma imagem ubuntu-latest, fazendo algumas instalações de Python, fazendo a instalação do flask. E é isso. Uma coisa importante nas imagens Docker que você sobe para o GitHub Packages é que ela contenha pelo menos esta Label aqui, do Open Containers, Image Source, e que aponte para o seu repositório. Então nesse nosso caso está como github.com/demolinkedin, que é a organização que eu estou usando, e o nome do projeto, demo-docker. Até aqui tudo certo. Temos a nossa imagem Docker. E agora vamos criar um Pipeline do GitHub actions. Vou criar os diretórios que nós já estamos acostumados, "github/workflows", e aqui eu vou criar um arquivo chamado workflow. yml. E nós iremos então criar o nosso Pipeline, que eu também já deixei pré-configurado. Vamos colar aqui. Vamos dar uma repassada por esse Pipeline. É um Pipeline bem simples, que irá realizar um Build Docker. A Trigger está para o processo manual com o Workflow Dispatch. E dentro do job nós temos já, logo de cara, a configuração de permissionamento do GitHub Token para que possa ler conteúdo e também escrever em pacotes. Descendo um pouco mais, nós temos a task de checkout para baixar o nosso código, no caso o Dockerfile, e logo abaixo temos a Task de Docker login. Eu estou usando essa action do Azure para realizar login no servidor do GitHub, que é o "ghcr.io", o username é o nome da sua conta. Se você estiver usando sua conta pessoal é o seu usuário, se tiver usando a organização é o nome da organização. E a senha pode ser o GITHUB_TOKEN Que, nesse caso, nós demos a permissão de escrita. Descendo um pouco mais abaixo, nós temos o processo de build da imagem Docker, onde estamos passando o Dockerfile e colocando a tag da imagem. Então aqui "ghcr.io", o nome da organização e aqui é o nome da imagem, que eu vou ajustar para demo-docker. E logo abaixo nós temos o push, que vai fazer o envio dessa imagem para dentro do Artifact. Nós vamos fazer a mesma coisa com o nome da imagem: "demo-docker", para que ele identifique que a mesma imagem que ele acabou de buildar vai ser a imagem enviada. Vamos realizar o Commit dessa alteração. Ok. E sincronizar. Voltando, então, ao repositório no menu de actions, agora nós temos um Pipeline chamado Build Docker, que vamos rodar manualmente. Pipeline está executando, vamos clicar nele, vamos clicar no Job de Build para acompanhar os logs. E aqui está configurando o Pipeline, já está realizando o Build da imagem. Está agora realizando o push da imagem para dentro do servidor do GitHub. Pipeline completo! Então agora vamos voltar ao topo da tela no menu code. Vamos descer um pouco. No menu lateral, em Packages, nós podemos visualizar este nosso pacote, a nossa imagem Docker. Se clicarmos neste link, nós podemos inclusive ver como utilizar essa imagem. Docker Pull e o Endpoint. E aqui nós podemos visualizar todas as informações dessa imagem, em repositórios atrelados, pessoas colaboradoras. Vamos voltar então na organização. Vamos clicar em demolinkedin no topo da tela e dentro da organização nós podemos acessar Packages. Aqui nós conseguimos ver todos os pacotes publicados, tanto NuGet, quanto Docker, quanto os demais tipos que você decide trabalhar. E, se eu clicar em demo-docker, nós vamos direto para o repositório, na área de pacotes.




Rodando pipelines a partir de uma issue
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos agora então criar um Pipeline para ser executado em eventos diferentes. Então, esse caso nós vamos criar baseados em uma issue. A ideia é, eu criei uma issue, eu possa realizar um comentário nessa issue usando o GitHub Actions, então vou para outra aba no meu VSCode e vamos criar a estrutura de diretórios para que possamos criar o Pipeline, que será: ".github/workflows". E dentro dessa pasta eu vou criar um arquivo "issue.yml". E agora vamos então criar o nosso Pipeline propriamente dito e vamos usar o GitHub Copilot para nos ajudar nessa situação. Vou colocar um comentário e "Crie um Pipeline no GitHub Actions para comentar em uma issue recém criada." Vamos ver se ele vai entender assim ou se eu preciso mudar o meu prompt. Deu o nome de issue. A Trigger veio para quando a issue for criada. Os Jobs. Deixa eu fechar esse terminal. E já trouxe aqui para nós o corpo deste Pipeline, onde ele vai rodar dentro de um Ubuntu-latest, e a ideia é que ele faça um comentário usando o GITHUB_TOKEN, e executando esse script, onde "github.issues.CreateComment" vai ter o issue number, que ele pega do contexto, o owner do repositório, que ele também pega do contexto, e o repositório, e ele vai escrever esta mensagem. Mas vamos mudar para "Boas Vindas ao Projeto." Uma outra coisa que nós precisamos mudar aqui é que o GitHub Actions não sugeriu o processo de permissão deste GITHUB_TOKEN, Ele está usando um GITHUB_TOKEN para poder se autenticar no GitHub e realizar este comentário. Mas esse token por padrão, ele não tem permissão para isso. Mas nós podemos configurar isso. Então, para essa configuração precisamos ir em runs-on, dá um ENTER para seguir o mesmo nível de indentação e cria a chave "permissions:", ENTER, "issues: write". E agora nós temos um Pipeline que, em tese, consegue interagir com a nossa issue. Então vamos colocar aqui a commit inicial. Sim, sincronizar essa alteração. Ok. E vamos voltar ao repositório, e agora vamos criar uma issue. Vamos então no menu de issues. E aqui em issues vamos clicar no botão nova issue. Dê um título para sua issue. Vou colocar "Issue de Teste". Vou colocar o teste na descrição e apertar o botão submit new issue. Agora vamos então acessar o menu de actions no topo da tela. Vou abrir numa nova aba. E notem que a nossa issue de teste já está executando o nosso Pipeline. E já rodou com sucesso nesse meio tempo. Voltemos para nossa issue. Podemos ver que ela foi atualizada e temos o nosso comentário. "Boas Vindas ao Projeto!"

Habilitar transcrições interativas



 Rodando pipelines a partir de um pull request
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos agora criar um Pipeline que será executado quando um pull request for criado. As possibilidades nesse caso são diversas. Você pode, por exemplo, criar um processo que irá executar um Pipeline quando o Request for criado, para validar se a aplicação está compilando, tudo certinho. Nesse nosso caso, nós vamos apenas realizar um comentário dentro do pull request. Então vamos ao nosso VSCode, na outra aba, e dentro do diretório workflows irei criar um novo arquivo chamado "pr.yml". E vamos utilizar mais uma vez o GitHub Copilot para nos ajudar na criação deste Pipeline. Então vou abrir um comentário e "Crie um pipeline no GitHub Actions que será executado quando um PR for aberto e inclua o seguinte comentário no PR: 'Obrigado pela sua alteração'." Ok, vamos iniciar as sugestões. Sugere o nome de PR. Ok, sem problemas. A Trigger quando um pull request for criado, ok. Jobs. Processo Build. Precisamos tirar essas três aspinhas que são geradas no final. Temos aqui todo o processo que vai interagir com o comentário e precisamos dar aquela permissão para que o token GITHUB_TOKEN consiga interagir com o pull request. Então vamos runs-on, demos um ENTER, permissions. Eu vou aqui... "pull requests: write". Aqui e eu vou também dar a permissão de "issues: write". Vamos commitar e sincronizar as alterações. Voltando ao projeto, vamos no menu Action para ver se essa action aparece na nossa lista. Ok. E vamos fazer uma pequena alteração em um arquivo qualquer, direto pela interface do GitHub. Então eu vou aqui em Edit File > Create new File. Vou incluir um arquivo de nome "teste.txt". Vou colocar no corpo "teste" e vou clicar no botão Commit Changes. Quando eu clicar no Commit Changes, eu vou mudar uma única coisa. Na parte inferior da tela que abriu eu não vou fazer um commit na branch main, eu vou fazer em uma nova branch e iniciar um pull request. Vou deixar o nome de branch sugerido por ele mesmo, Propose Changes. Já abriu a tela do pull request. Vamos descer um pouco e clicar no botão Create Pull Request. E agora vamos ver se a nossa action está rodando. Vamos no menu de action na outra aba. Está rodando o pull request. Vamos visualizar. Aparentemente tudo certo. Vamos voltar ao Pull Request e temos o nosso comentário automático. "Obrigado pela sua alteração." Lembrando que você pode fazer outros tipos de execução quando um pull request for criado, como, por exemplo, um processo de CI.


 Rodando pipelines a partir de um pull request
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Vamos agora criar um Pipeline que será executado quando um pull request for criado. As possibilidades nesse caso são diversas. Você pode, por exemplo, criar um processo que irá executar um Pipeline quando o Request for criado, para validar se a aplicação está compilando, tudo certinho. Nesse nosso caso, nós vamos apenas realizar um comentário dentro do pull request. Então vamos ao nosso VSCode, na outra aba, e dentro do diretório workflows irei criar um novo arquivo chamado "pr.yml". E vamos utilizar mais uma vez o GitHub Copilot para nos ajudar na criação deste Pipeline. Então vou abrir um comentário e "Crie um pipeline no GitHub Actions que será executado quando um PR for aberto e inclua o seguinte comentário no PR: 'Obrigado pela sua alteração'." Ok, vamos iniciar as sugestões. Sugere o nome de PR. Ok, sem problemas. A Trigger quando um pull request for criado, ok. Jobs. Processo Build. Precisamos tirar essas três aspinhas que são geradas no final. Temos aqui todo o processo que vai interagir com o comentário e precisamos dar aquela permissão para que o token GITHUB_TOKEN consiga interagir com o pull request. Então vamos runs-on, demos um ENTER, permissions. Eu vou aqui... "pull requests: write". Aqui e eu vou também dar a permissão de "issues: write". Vamos commitar e sincronizar as alterações. Voltando ao projeto, vamos no menu Action para ver se essa action aparece na nossa lista. Ok. E vamos fazer uma pequena alteração em um arquivo qualquer, direto pela interface do GitHub. Então eu vou aqui em Edit File > Create new File. Vou incluir um arquivo de nome "teste.txt". Vou colocar no corpo "teste" e vou clicar no botão Commit Changes. Quando eu clicar no Commit Changes, eu vou mudar uma única coisa. Na parte inferior da tela que abriu eu não vou fazer um commit na branch main, eu vou fazer em uma nova branch e iniciar um pull request. Vou deixar o nome de branch sugerido por ele mesmo, Propose Changes. Já abriu a tela do pull request. Vamos descer um pouco e clicar no botão Create Pull Request. E agora vamos ver se a nossa action está rodando. Vamos no menu de action na outra aba. Está rodando o pull request. Vamos visualizar. Aparentemente tudo certo. Vamos voltar ao Pull Request e temos o nosso comentário automático. "Obrigado pela sua alteração." Lembrando que você pode fazer outros tipos de execução quando um pull request for criado, como, por exemplo, um processo de CI.



 Rodando pipelines manualmente
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Uma outra opção de Trigger que é extremamente útil é a possibilidade de você executar seu Pipeline manualmente, porque em todos os processos de Pipeline que nós costumamos criar, nós dependemos que algum evento específico aconteça, como um pull request, como a criação de uma issue, como um commit. Mas se você precisar executar manualmente não vai ser possível. Então, para isso existe a possibilidade de colocarmos uma Trigger específica para isso. Então vamos ao nosso VSCode na outra aba e dentro da nossa estrutura de diretórios, ".github/workflows", nós vamos criar um novo arquivo chamado "manual.yml". E dentro desse arquivo vamos usar a ajuda do GitHub Copilot mais uma vez, e "Crie um Pipeline do GitHub Actions que execute manualmente e escreva na tela 'Olá, mundo!'". Isso está bom. Sugeri o nome de manual. A trigger é a workflow_dispatch. Esta é a trigger que nos permite executar o processo de Pipeline manualmente, que nós vamos ver em alguns instantes. Vamos dar um ENTER, deixar a criação dos Jobs e o processo de Pipeline. Esse é bem simples, está apenas colocando um echo "Hello, World!". Ou melhor, echo "Olá, mundo!", já que estamos criando em português e vamos realizar o commit desta alteração, sincronizar e vamos voltar ao nosso repositório e já clicar em actions. Você pode ver na lista de actions no menu lateral que agora nós temos a opção manual. Clique nessa opção e no centro da tela nós podemos ver o manual, o "manual.yml", podemos ver a lista de execuções, que nesse caso está vazia, e aparece uma barra onde está escrito "This workflow has a workflow_dispatch event trigger." Ou seja, "este workflow tem a Trigger workflow_dispatch". E aparece um ComboBox, um Dropdown, chamado Run workflow. Você pode clicar nesse dropdown e nesse dropdown você pode escolher a partir de qual branch o seu Pipeline vai rodar. No meu caso, será a main e você pode clicar no botão Run workflow. E assim o nosso Pipeline está sendo executado manualmente.

 Rodando pipelines no push
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Uma opção muito comum de Trigger para Pipeline é quando você faz efetivamente um push do seu código, ou seja, quando você envia o código da sua máquina para o GitHub. Então, para isso, vamos ao nosso VSCode, que está na outra aba, e dentro do diretório workflows eu vou criar um novo arquivo chamado "commit.yml". E dentro desse arquivo vamos usar o GitHub Copilot para nos ajudar a "Criar um Pipeline no GitHub Actions que será executado quando um push for realizado para a branch main e escreva na tela 'Olá, mundo!'" Acho que isso funciona. E ele já começa a sugerir o name: push". A Trigger on, push na branch main. Os jobs. Não tem muito segredo aqui, vai executar no Ubuntu-latest e vai rodar um "Olá, mundo!". O ponto aqui é que quando nós realizarmos o commit e sincronizar essa alteração, automaticamente esse Pipeline será executado. Por quê? Porque ele está configurado para ser executado como um push na branch main. Então vamos efetuar este nosso commit. Vamos voltar para o repositório até esse ponto antes de eu sincronizar e clicar em actions. Você pode ver que esta opção nem existe. Essa nova action nem existe no menu de actions. Isso não existe porque nós não sincronismos ainda com o nosso repositório. Vamos voltar para o VSCode e sincronizar essa alteração. Ok, vamos voltar aqui para o GitHub, atualizar a tela. E agora vejam que apareceu na lista a opção de push e já, automaticamente, está sendo executado, como nós havíamos conversado.

 Rodando pipelines no push para branches específicas
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Outra opção neste caso é se você quiser rodar seu Pipeline para pushs e branchs específicas, não exclusivamente na main. Para isso, vamos voltar ao nosso VSCode e vamos usar este mesmo arquivo. Vejam que nesse caso nós temos uma Trigger na branch main, mas digamos que você quer que isso rode numa branch de feature, por exemplo. Para isso basta você modificar para "feature/*", porque, o que acontece neste caso? Ele identificará que esse Pipeline deverá rodar toda vez que for realizado um push para uma branch de feature. Independente de qual seja o nome dessa branch, desde que ela esteja nessa estrutura, feature/alguma coisa. Então vamos efetuar o nosso commit. Preciso colocar a mensagem, esqueci disso. E sincronizar a nossa alteração. Ok, vamos voltar ao GitHub e clicar em actions. Vejam que agora o nosso pipeline de push não foi executado. Então o que nós vamos fazer? Eu vou em code, clicar nesta opção onde está o main e vou criar uma nova branch chamada "feature/teste." Vejam que surgiu uma opção, como essa branch não existe, escrita create branch, ou seja, como não existe, vamos criar uma nova. Criamos. Estamos na branch feature/teste e eu vou adicionar um novo arquivo aqui. Demo. E aqui vou incluir Demo também. Vou clicar em Commit Changes. Vou fazer o commit diretamente em feature/teste. E agora voltemos para o menu de actions. Vejam que agora temos um Pipeline rodando porque nós fizemos o commit em feature/teste. Nosso Pipeline se executando apenas com repositórios feature/alguma coisa.


 Usando o GitHub Actions para outras atividades
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Utilizando o GitHub Actions para outras atividades. O que quer dizer isso? Quando nós estamos utilizando o GitHub Actions, as possibilidades são imensas do que nós podemos fazer. Nós não precisamos ficar apenas presos a um Pipeline de Build Deployment ou um Pipeline de CI/CD, caso você prefira. Você pode fazer uma série de outras coisas, como nós já viemos comentando no decorrer deste nosso curso. E aqui eu queria deixar para você algumas sugestões do que você pode realizar com o GitHub Actions. E algumas dessas sugestões são: respostas em issues ou verificação de descrição de uma issue. Dessa forma, você pode interagir com essa issue da forma que melhor fizer sentido. Você pode, por exemplo, incluir uma inteligência artificial para te ajudar nessas respostas ou te ajudar a entender a descrição dessa issue e tomar uma atitude. Você entende a possibilidade? Aqui começa a ficar interessante e não é um Pipeline de Deployment. Outra coisa que você pode fazer é validar informações de um Pull Request, ou mesmo trabalhar com GitHub Pages ou interagir com dados externos. Essa última parte aqui, por exemplo, eu uso hoje dentro do meu repositório do GitHub para obter dados do meu canal do YouTube, vídeos que eu publico no meu canal do YouTube e atualizar o meu perfil do GitHub Star com essas contribuições. Então você consegue automatizar várias coisas diferentes usando o GitHub Actions.

 Garantindo a segurança do pipeline - Parte 1
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Uma questão muito importante quando estamos trabalhando com Pipelines dentro do GitHub Actions é também nos preocuparmos com a segurança deste nosso Pipeline. Porque, afinal de contas, nós estamos executando automações e, se tudo não for muito bem planejado, nós podemos, sim, criar brechas de segurança no Pipeline do GitHub Actions. A segurança também é uma preocupação dentro dos nossos Pipelines do GitHub Actions. Por quê? Bom, basicamente nós estamos executando uma automação e essa automação interage das mais diversas formas com o nosso ambiente, com o nosso sistema operacional e por isso nós devemos, sim, nos preocupar com o que nós estamos fazendo, com o que está sendo executado e como isso está sendo feito. Então, para isso, nós precisamos pensar em algumas coisas, como, por exemplo, alguns dos pontos de segurança que valem a pena nós analisarmos aqui. Usar credenciais com apenas as permissões necessárias. Isso serve para você evitar que, caso alguma pessoa maliciosa tenha acesso ao seu Pipeline, consiga fazer coisas indevidas, como, por exemplo, sair criando máquinas virtuais no seu ambiente de nuvem aleatoriamente, sem que você saiba disso, sem que você tenha controle disso. Se você tiver aqui uma credencial configurada apenas a um grupo de recursos específicos, por exemplo, isso seria evitado. Porque você saberia, teria um controle daquele grupo de recursos que você já limitou, que você já fez uma série de validações de segurança, seu time de TI já bloqueou muita coisa, então você conseguiria restringir este tipo de coisa e evitar problemas maiores. Uma outra sugestão bastante interessante é você fazer as rotações de chaves periodicamente, porque nós criamos secrets dentro do GitHub Actions com chaves de acesso e caso essas chaves vazem, nós também teremos problemas. Então, de tempos em tempos é legal você fazer um tipo de rotação nessas chaves. Outro ponto importante é você utilizar um CODEOWENERS dentro do seu GitHub para monitorar as alterações em Pipelines. O CODEOWENERS serve para quando você criar um pull request, por exemplo, você definir aprovadores específicos. Então você pode garantir que sempre que o diretório ".github/workflows" receber uma alteração, você precisará ser avisado, para que você possa realizar uma análise e aprovação desta alteração. E uma outra questão importante é você evitar a injeção de scripts no seu Pipeline. Por quê? Porque dessa forma, você evita que, por exemplo, sejam executados comandos de sistema operacional indevidamente.


 Garantindo a segurança do pipeline - Parte 2
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Uma vulnerabilidade que eu queria mostrar para você é como nós podemos resolver e tratar o problema de injeção de código. Por que que isso é problemático? Porque, bom, se você não souber trabalhar esse tipo de problema, você pode acabar permitindo a execução de comandos de sistema operacional dentro do seu Pipeline, e você, honestamente, não vai querer isso, já que isso traz uma série de problemas gravíssimos de segurança, como extração de dados, entre outras coisas. Então, pensando nisso, eu já criei nesse meu repositório um Pipeline, que nós podemos visualizar aqui, onde ele será executado quando uma issue for aberta e, se você olhar nos passos, nos steps, você verá uma task bem simples, que ela está escrevendo um valor na tela. E esse valor é o valor do evento da issue, que é o "github.event.issue.title". Ou seja, ele vai obter o título desta nossa issue e escrever na nossa tela. Em teoria, algo muito simples, algo muito tranquilo. Vamos então criar uma nova issue. Eu vou abrir isso numa nova aba. E vamos clicar no botão Nova Issue. Dentro dessa minha issue o que eu quero fazer? Eu vou executar o seguinte comando, vou colocar o seguinte título na minha issue: "test" && ls - la && echo "teste." Por quê? Vamos voltar a estrutura do nosso Pipeline. Vejam que o meu comando dentro de run é "echo", abre aspas, coloca o valor do título, fecha aspas. O que eu estou fazendo com esse título? Eu estou colocando um texto aqui de teste, fechando aspas para que ele entenda que é para executar o comando echo. Estou usando os dois &, do "ls" e "la" para concatenar este comando de listagem de diretórios. E estou colocando dois & para concatenar um novo comando, que é o "echo "teste", e aí ele vai executar o fechamento com essa outra aspas que está aqui. Então nós estamos adentrando este nosso Pipeline com uma pequena brecha para executar comandos de sistema operacional. Quer ver isso acontecendo? Vamos então submeter esta issue. Submetemos. Então nós precisamos agora fazer o quê? Ir ao menu de actions para acompanhar a execução. Vejam que esse Workflow já está sendo executado. Vamos clicar no link. Vamos então clicar no Job. E já foi executado e vamos ver o que aconteceu nessa task do echo. Vejam que o comando, ele se concatenou da forma que eu disse. Teste, fecha aspas, ls e la e o teste". Ele executou então o primeiro echo teste e logo em seguida o nosso "ls". Ou seja, nós conseguimos executar este comando de sistema operacional aqui e logo em seguida ele executou o outro teste. Como estava dizendo antes, isso é problemático porque desta forma você conseguiria, por exemplo, abrir um shell reverso para este runner que por agora está sendo executado dentro de um runner do GitHub Actions e o máximo que ele vai poder fazer dentro do seu ambiente é extra filtrar os seus códigos, o quê, confesso, já é muito problemático, certo? Imaginem que então este runner está rodando dentro da sua empresa e você não tratou esse tipo de problema. Essa pessoa maliciosa poderia abrir um shell reverso dentro do seu ambiente e ter acesso a dados da sua empresa. E se o seu runner não estiver bem configurado com permissões e isolamentos, isso pode ser muito grave. Então nós precisamos nos preocupar em tratar este tipo de coisa dentro dos nossos Pipelines. Vamos voltar na outra aba, então, no nosso Pipeline, e fazer uma pequena edição. Dentro desse nosso Pipeline nós vamos então realizar este tratamento para que isso não aconteça mais. Então, o que nós vamos fazer? Logo abaixo da chave de runs-on, você irá criar uma nova chave chamada "env:" e dentro de env: você cria uma variável, que eu vou chamar de Issue title. E dentro dessa Issue title, o que nós precisamos fazer? Nós precisamos apenas receber este valor do evento de título, então vou copiar de dentro do echo. E vou colocar aqui. Agora nós precisamos de uma outra mudança. Dentro do passo de echo, nós vamos remover este evento e vamos usar a variável. Então permanece o cifrão e o valor da variável: "ISSUE_TITLE". Vamos então realizar o commit desta alteração. E vamos criar uma nova issue. Dentro dessa issue, vamos colocar exatamente o mesmo título para ver o que acontece dessa vez. Vamos submeter esta issue. Submetida. Vamos então agora para as actions e ver o que está acontecendo. O comando está executando. Vamos visualizar os logs. Veja que já rodou. E agora nós podemos ver algo diferente. Ele não concatenou este comando junto com echo e rodou o sistema operacional. Não, ele entendeu que o título é basicamente uma string. E ele apenas escreveu essa string, mitigando justamente esse problema das vulnerabilidades de injeção de código. Então nós conseguimos, dessa forma, manter o Pipeline seguro para este tipo de vulnerabilidade.




Criando condições nos pipelines
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Agora eu queria mostrar para você como que você pode utilizar condições dentro do seu pipeline. Isso pode ser muito útil para se, por exemplo, você quer que algum passo execute apenas em um cenário específico, como, por exemplo, a partir de uma branch específica, ou se alguma condição muito específica do seu ambiente for atendida. Para isso eu criei um workflow, que nós vamos visualizar agora, bem simples. Esse é um Pipeline de CI, que executa manualmente, já que nós podemos ver a trigger workflow_dispatch e ele não faz nada demais. Do jeito que ele está hoje, ele pode ser executado por qualquer branch, mas o que eu quero fazer? Eu quero que esse pipeline seja executado apenas dentro de um determinado cenário. Por exemplo, eu quero que ele seja executado apenas se o meu código vier da branch de feature. Se vier da branch main, eu não quero que ele faça nada. E o que eu preciso fazer para isso? Bom, eu já tenho esse código pronto, mas basicamente nós vamos incluir, logo abaixo de runs-on, o seguinte bloco de código: if, que é uma condicional, se contiver dentro de github.ref, este seguinte ID: ref.heads.feature/. Aí sim o pipeline poderá ser executado. Ou seja, este pipeline será executado apenas se você criar um branch feature barra alguma coisa. Vamos realizar o commit dessas alterações e vamos testar este conceito. Vou clicar em Actions. Vamos tentar rodar este pipeline a partir da branch main. Vamos ver a execução. E vejam no log que o símbolo apareceu este círculo com o tracinho no meio dentro do job. Isso significa que esse job não foi executado. Inclusive, nós podemos ver no log "This job was skipped", ou seja, esse job foi pulado. Então esse pipeline não executou porque ele não atendeu a condição. Vamos tentar atender essa condição. Vou clicar no menu de code, logo nesse dropdown que aparece para nós no topo da tela, logo abaixo do nome do repositório, onde está o nome de main ou da sua branch que você estiver rodando, nós podemos expandi-lo e criar uma nova branch ou buscar uma nova branch. Eu vou então criar, digitando o nome que não existe, "feature/demo". E vejam que aparece a opção de criar branch a partir da main. Criamos então a branch, vamos voltar para actions, e agora vamos executar este pipeline no Run workflow e em vez de usar a branch main vamos expandir e para a feature/demo e executar o workflow. Vamos ver então a execução. Vamos acompanhar o job. E vejam que agora o job está startando e está sendo executado. Então nós conseguimos atender às condições específicas de cada cenário.

Habilitar transcrições interativas





Projeto Real: Gerador de badges para eventos com GitHub
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Eu queria mostrar para você um projeto que eu criei usando o GitHub e GitHub Actions para automatizar um processo para os meus eventos que eu executo para a comunidade. Esse projeto se chama Events Badge Generator. Este é um repositório que ele é público, se você clicar no link abaixo, você consegue abrir o template dele, mas este especificamente, arruda-events-badge, é o que eu uso para os meus eventos e o que ele faz, basicamente, é gerar badges. Vamos descer um pouco a tela, eu tenho algumas informações aqui. Por exemplo, ele gera badges nesse estilo com uma pequena imagem e os dados do evento publicados dentro do GitHub Pages, que também é uma forma de você publicar sites estáticos dentro do GitHub. Vamos subir um pouco a tela. Aqui eu faço muitas coisas e uso o GitHub actions para orquestrar isso. Por exemplo, se nós clicarmos dentro da pasta GitHub, nós podemos visualizar o diretório workflows e nós temos alguns pipelines, como por exemplo este event, onde eu cadastro os meus eventos e ele é executado sempre que uma issue é criada. E se você descer um pouco mais, você pode ver que eu também uso condições aqui para verificar se o título da minha issue contém o texto conference, para saber que nesse caso estou cadastrando conferência. E aí estou tratando todos os dados, expondo dados, clonando o repositório, fazendo todo o necessário para cadastrar este evento dentro do meu projeto. Se nós formos para outro workflow, como por exemplo o badge-desafio, nós temos também o mesmo cenário. Ele executa quando a issue é aberta, tem a condição do título conter "Desafio 1". E vai sendo executado os passos de tratamento, geração de badge, criação do participante e tudo mais. Vamos visualizar um processo desses sendo executado. Eu vou dentro da minha issue e vou criar uma nova issue aqui dentro. Nós temos já um template de issue para cadastro de evento, não é esse que eu vou usar, então eu vou abrir uma issue em branco. E aqui no título eu vou colocar o seguinte para atender àquela condição. "[Desafio 1] Julio Arruda". E aqui na descrição eu preciso passar os dados que eu já espero no meu pipeline para que isso seja executado. Também já tem isso pronto, vou copiar e vou colar aqui. que basicamente é o nome do participante, um ID interno que ele usa, os dados do evento que foram cadastrados e o meu e-mail. Vou submeter esta nova issue e vamos ver agora o que acontece. Vamos clicar no menu de actions. Vejam que ele startou três issues e entendeu que duas não seriam executadas, mas está rodando esta última aqui. Vamos clicar nela. Vejam que está rodando um processo de build. Ele tem esse pequeno Sleep para evitar conflitos, já que eu uso isso em eventos e podem ser que tenham várias pessoas tentando rodar ao mesmo tempo. Ele está aqui agora, obtendo informação, criando a página, fechando a issue e terminou. Se nós clicarmos em Actions mais uma vez, nós podemos ver que tem uma outra Action rodando, essa já do GitHub Pages, para buildar a minha página. Mas podemos voltar a nossa issue. Ele fechou essa issue, essa issue aberto é de outro teste, podemos ir nas issues fechadas, já que ele acabou de fechar, pegar a primeira, que é o caso do que nós criamos e descer um pouco a página e ver o comentário que o nosso bot gerou. A Badge está disponível em, na minha URL, que nós podemos clicar e temos aqui "Validação de certificados - Consultoria, Arruda Consultorias e Treinamentos" e temos a nossa badge. "Desafio 1 de primeiros passos", e tem aqui todo um descritivo de quando o certificado foi emitido. Ele está em loop porque eu to criando vários para mim, e ele cria na mesma página por causa do ID, mas basicamente isso aqui se torna uma badge que você pode compartilhar nas suas redes sociais. Então entendam que você consegue fazer uma série de outras coisas com GitHub Actions. Estou eu aqui automatizando um projeto totalmente diferente, que não CI/CD, que na realidade gera uma página em um site estático para que você possa compartilhar a badge das suas participações em eventos.

Habilitar transcrições interativas



 Recursos adicionais para o GitHub Actions
Quando você selecionar uma linha na transcrição, será direcionado à seção equivalente no vídeo
Bom, chegamos ao fim do nosso curso sobre GitHub Actions, espero que você tenha gostado e aprendido muita coisa. E eu gostaria de deixar para você alguns links onde você pode aprofundar ainda mais os seus conhecimentos em GitHub e GitHub Actions. O primeiro deles é um pouco do meu conteúdo, onde você pode encontrar dentro do meu canal no YouTube, basta procurar pelo meu nome ou youtube.com/@julioarruda e lá eu tenho várias playlists falando de GitHub nos mais diversos cenários. Então eu tenho uma playlist mais recente denominada "GitHub Mão na Massa", onde tem uma série de conteúdos passo a passo e práticos de toda a parte do GitHub, desde o início até o final do que você precisa e vários outros vídeos soltos aqui também. Aqui estão separados por várias playlists, mas você pode procurar no meu canal. Outro link muito importante é o skills.github.com. Aqui você pode aprender tudo o que você precisa sobre GitHub e também sobre GitHub Actions. Tem uma seção exclusiva sobre automações com GitHub Actions para que você possa aprender também. E mais um link que eu acho muito importante é o Learning Path da Microsoft, onde nós temos todo um Learning Path de automação de workflows com GitHub Actions e você pode aprender também basicamente todo o necessário para que você consiga tirar o melhor proveito deste produto. Então espero que vocês tenham gostado desse nosso curso. Não deixem de acompanhar esse e outros cursos dentro da plataforma do LinkedIn Learning e nos vemos em breve.



Build --> Compilação --> Teste Unitário --> Análise de Qualidade --> Geração de Artefato

Deploymenbt --> Quais os ambientes --> Será necessário a implantação --> Criação de Recurso de Infra --> Configuração de ambiente --> Implantação da Aplicação

Extras --> Teste de Fuma --> Teste de Segurança --> Monitoramento da Aplicação.




No Agile, o gerenciamento de lançamentos não se trata apenas de implantar código; trata-se de entregar valor de forma rápida, eficiente e com risco mínimo. Uma estratégia de lançamento bem estruturada garante que as equipes possam entregar continuamente, adaptar-se rapidamente e manter a alta qualidade.

Principais aspectos do gerenciamento ágil de lançamentos:

✅ Entrega e implantação contínuas – Automatizando compilações, testes e implantações para garantir um fluxo contínuo do desenvolvimento à produção.
✅ Alternâncias de recursos e lançamentos canários – Implantando novos recursos com segurança, minimizando riscos e coletando feedback antecipado.
✅ Colaboração multifuncional – Desenvolvedores, testadores, proprietários de produtos e equipes de operações trabalhando juntos para lançamentos tranquilos.
✅ Planejamento de lançamento e roteiros – Alinhando sprints com metas de negócios, priorizando recursos e garantindo prontidão para produção.
✅ Teste e monitoramento automatizados – Detectando defeitos antecipadamente, garantindo o desempenho e monitorando a estabilidade após o lançamento.

Práticas recomendadas para lançamentos contínuos:

🔹 Planeje e priorize – Defina metas de lançamento, dependências e resultados esperados no início do sprint.
🔹 Automatize tudo o que for possível – De testes a pipelines de implantação, a automação reduz erros manuais e acelera os lançamentos.
🔹 Lançamento frequente e iterativo – Atualizações pequenas e incrementais reduzem o risco e melhoram a capacidade de resposta às necessidades do mercado.
🔹 Monitore e aprenda – O monitoramento pós-lançamento e as retrospectivas ajudam a melhorar as implantações futuras.
🔹 Habilitar reversões – Tenha uma estratégia de reversão em vigor para lidar com problemas inesperados com o mínimo de interrupção.

💡 Um forte processo de gerenciamento de lançamentos ágil garante que as organizações possam inovar rapidamente, mantendo a estabilidade e a qualidade.
